<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ITK: itk::VariableLengthVector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="ITK"/>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<script type="text/javascript" src="build_text.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ITKDoxygenStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="itkLogoSmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ITK
   &#160;<span id="projectnumber">5.3.0</span>
   </div>
   <div id="projectbrief">Insight Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--  Scripts intended to allow users to submit patches with documentation fixes -->
<!-- <script src="https://www.itk.org/Doxygen/js/jquery-1.4.3.min.js" type="text/javascript" charset="utf-8"></script> -->
<!-- <script src="https://www.itk.org/Doxygen/js/editdoxygen.js" type="text/javascript" charset="utf-8"></script> -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,true,'search.php','Search');
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceitk.html">itk</a></li><li class="navelem"><a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classitk_1_1VariableLengthVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">itk::VariableLengthVector Class Reference<div class="ingroups"><a class="el" href="group__DataRepresentation.html">Data Representation Objects</a><a class="el" href="group__Group-Core.html">Group Core</a> &raquo;  &#124; <a class="el" href="group__ITKCommon.html">Module ITKCommon</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="itkConstantBoundaryCondition_8h_source.html">itkConstantBoundaryCondition.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1AllocateRootPolicy.html">AllocateRootPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1AlwaysReallocate.html">AlwaysReallocate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1DontShrinkToFit.html">DontShrinkToFit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1DumpOldValues.html">DumpOldValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1KeepOldValues.html">KeepOldValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1KeepValuesRootPolicy.html">KeepValuesRootPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1NeverReallocate.html">NeverReallocate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structitk_1_1VariableLengthVector_1_1ShrinkToFit.html">ShrinkToFit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af5001bcf6a9e8567fa185610430a5e90"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#af5001bcf6a9e8567fa185610430a5e90">ComponentType</a> = TValue</td></tr>
<tr class="separator:af5001bcf6a9e8567fa185610430a5e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3405e9cd0ebe9c0dd741d5f5911a7b8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">ElementIdentifier</a> = unsigned int</td></tr>
<tr class="separator:a3405e9cd0ebe9c0dd741d5f5911a7b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13766c0f231fc7cdaceeebbf9ba06c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ad13766c0f231fc7cdaceeebbf9ba06c6">RealValueType</a> = typename <a class="el" href="classitk_1_1NumericTraits.html">NumericTraits</a>&lt; <a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">ValueType</a> &gt;::RealType</td></tr>
<tr class="separator:ad13766c0f231fc7cdaceeebbf9ba06c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2400a451d7131001088023ffd857f1fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> = <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a></td></tr>
<tr class="separator:a2400a451d7131001088023ffd857f1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6111db02041ab7eb748c67f26a48df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">ValueType</a> = TValue</td></tr>
<tr class="separator:a7b6111db02041ab7eb748c67f26a48df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a50e65a3ca102fa181e871232d0a00b5c"><td class="memItemLeft" align="right" valign="top">TValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a50e65a3ca102fa181e871232d0a00b5c">AllocateElements</a> (<a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">ElementIdentifier</a> size) const</td></tr>
<tr class="separator:a50e65a3ca102fa181e871232d0a00b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05965b2457247f3ff3a376353c65c0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a05965b2457247f3ff3a376353c65c0a6">DestroyExistingData</a> ()</td></tr>
<tr class="separator:a05965b2457247f3ff3a376353c65c0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76bf30dc0eb546a95f69c7741585aa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ad76bf30dc0eb546a95f69c7741585aa3">FastAssign</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;v)</td></tr>
<tr class="separator:ad76bf30dc0eb546a95f69c7741585aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea82d1c7a0680533fb73cc4ab1af4c7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#aea82d1c7a0680533fb73cc4ab1af4c7d">Fill</a> (TValue const &amp;v)</td></tr>
<tr class="separator:aea82d1c7a0680533fb73cc4ab1af4c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215998cc438efbe863609c19cc29feb8"><td class="memItemLeft" align="right" valign="top">const TValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a215998cc438efbe863609c19cc29feb8">GetDataPointer</a> () const</td></tr>
<tr class="separator:a215998cc438efbe863609c19cc29feb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19043c11455fa9f7a7329a9504f5b7f"><td class="memItemLeft" align="right" valign="top">const TValue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ae19043c11455fa9f7a7329a9504f5b7f">GetElement</a> (unsigned int i) const</td></tr>
<tr class="separator:ae19043c11455fa9f7a7329a9504f5b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3592a6f501ea61701068eec95a278164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#ad13766c0f231fc7cdaceeebbf9ba06c6">RealValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a3592a6f501ea61701068eec95a278164">GetNorm</a> () const</td></tr>
<tr class="separator:a3592a6f501ea61701068eec95a278164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedda7a4bb6f16e673f595096963c797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#ad13766c0f231fc7cdaceeebbf9ba06c6">RealValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#afedda7a4bb6f16e673f595096963c797">GetSquaredNorm</a> () const</td></tr>
<tr class="separator:afedda7a4bb6f16e673f595096963c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8ccb4bd105d3bd09ea90133966ce22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a0a8ccb4bd105d3bd09ea90133966ce22">IsAProxy</a> () const</td></tr>
<tr class="separator:a0a8ccb4bd105d3bd09ea90133966ce22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f2a9e5b53188ea4a0feec328c0e8c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#af4f2a9e5b53188ea4a0feec328c0e8c2">ITK_UNEQUAL_OPERATOR_MEMBER_FUNCTION</a> (<a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>)</td></tr>
<tr class="separator:af4f2a9e5b53188ea4a0feec328c0e8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e3a1078247b3f8fe6e61ea1f54e64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a74e3a1078247b3f8fe6e61ea1f54e64f">operator-</a> ()</td></tr>
<tr class="separator:a74e3a1078247b3f8fe6e61ea1f54e64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2932f230d47190fb85da909755f13eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a2932f230d47190fb85da909755f13eb1">operator=</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;v)</td></tr>
<tr class="separator:a2932f230d47190fb85da909755f13eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc0bfa5d5520901b5f69288b4acc5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a1fc0bfa5d5520901b5f69288b4acc5e4">operator=</a> (<a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a1fc0bfa5d5520901b5f69288b4acc5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a48440caf7a5dfe57b44938139d966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a42a48440caf7a5dfe57b44938139d966">operator=</a> (TValue const &amp;v)</td></tr>
<tr class="separator:a42a48440caf7a5dfe57b44938139d966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af806aa3e3d76bdb4a1e02b8a696a2834"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </td></tr>
<tr class="memitem:af806aa3e3d76bdb4a1e02b8a696a2834"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#af806aa3e3d76bdb4a1e02b8a696a2834">operator=</a> (<a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;rhs)</td></tr>
<tr class="separator:af806aa3e3d76bdb4a1e02b8a696a2834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc050a6c37fbb72c6153c5144491d28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a4dc050a6c37fbb72c6153c5144491d28">operator==</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;v) const</td></tr>
<tr class="separator:a4dc050a6c37fbb72c6153c5144491d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d85366b1efcdc7f0bf0e1a591769190"><td class="memItemLeft" align="right" valign="top">TValue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a0d85366b1efcdc7f0bf0e1a591769190">operator[]</a> (unsigned int i)</td></tr>
<tr class="separator:a0d85366b1efcdc7f0bf0e1a591769190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc51511d476c4c215c88dde29789795a"><td class="memItemLeft" align="right" valign="top">const TValue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#afc51511d476c4c215c88dde29789795a">operator[]</a> (unsigned int i) const</td></tr>
<tr class="separator:afc51511d476c4c215c88dde29789795a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f2f6ca38a442f2a63edee6b090600d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a73f2f6ca38a442f2a63edee6b090600d">SetData</a> (TValue *datain, bool LetArrayManageMemory=false)</td></tr>
<tr class="separator:a73f2f6ca38a442f2a63edee6b090600d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d88fa71693d811e58eb1dd01f358e36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a8d88fa71693d811e58eb1dd01f358e36">SetData</a> (TValue *datain, unsigned int sz, bool LetArrayManageMemory=false)</td></tr>
<tr class="separator:a8d88fa71693d811e58eb1dd01f358e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae629d9c525c44a8372cff0522195b233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ae629d9c525c44a8372cff0522195b233">SetElement</a> (unsigned int i, const TValue &amp;value)</td></tr>
<tr class="separator:ae629d9c525c44a8372cff0522195b233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8610c53a2496c1e8d7c105c430a0b0ec"><td class="memTemplParams" colspan="2">template&lt;typename TReallocatePolicy , typename TKeepValuesPolicy &gt; </td></tr>
<tr class="memitem:a8610c53a2496c1e8d7c105c430a0b0ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a8610c53a2496c1e8d7c105c430a0b0ec">SetSize</a> (unsigned int sz, TReallocatePolicy reallocatePolicy, TKeepValuesPolicy keepValues)</td></tr>
<tr class="separator:a8610c53a2496c1e8d7c105c430a0b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051f13f8bcfb3451344b3b02c01b7c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a2051f13f8bcfb3451344b3b02c01b7c5">VariableLengthVector</a> ()</td></tr>
<tr class="separator:a2051f13f8bcfb3451344b3b02c01b7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6328ba722ccf04a948eb71f84b174e52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a6328ba722ccf04a948eb71f84b174e52">VariableLengthVector</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">ValueType</a> *datain, unsigned int sz, bool LetArrayManageMemory=false)</td></tr>
<tr class="separator:a6328ba722ccf04a948eb71f84b174e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8bb674772c4367543f3fc96a77c8d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a9a8bb674772c4367543f3fc96a77c8d2">VariableLengthVector</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; TValue &gt; &amp;v)</td></tr>
<tr class="separator:a9a8bb674772c4367543f3fc96a77c8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b4ece405c3ea70fba0fa334b7d3130"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a68b4ece405c3ea70fba0fa334b7d3130">VariableLengthVector</a> (<a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a68b4ece405c3ea70fba0fa334b7d3130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac092e28bcbe220ace0f1c6273a2251ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ac092e28bcbe220ace0f1c6273a2251ab">VariableLengthVector</a> (unsigned int length)</td></tr>
<tr class="separator:ac092e28bcbe220ace0f1c6273a2251ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7548854c7542959b4572abb96a3ca302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a7548854c7542959b4572abb96a3ca302">VariableLengthVector</a> (<a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">ValueType</a> *datain, unsigned int sz, bool LetArrayManageMemory=false)</td></tr>
<tr class="separator:a7548854c7542959b4572abb96a3ca302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f1f29e49f5371c71db623d20a33b30"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </td></tr>
<tr class="memitem:a70f1f29e49f5371c71db623d20a33b30"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a70f1f29e49f5371c71db623d20a33b30">VariableLengthVector</a> (<a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;rhs)</td></tr>
<tr class="separator:a70f1f29e49f5371c71db623d20a33b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bec5f9a30ef12f70983f1abd2755ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a36bec5f9a30ef12f70983f1abd2755ef">~VariableLengthVector</a> ()</td></tr>
<tr class="separator:a36bec5f9a30ef12f70983f1abd2755ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3556c3d6e08b14e372677ac893de9262"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3556c3d6e08b14e372677ac893de9262"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a3556c3d6e08b14e372677ac893de9262">VariableLengthVector</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a3556c3d6e08b14e372677ac893de9262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa3b5c8c30850e1d45da44db27052452c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#aa3b5c8c30850e1d45da44db27052452c">Swap</a> (<a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;v) noexcept</td></tr>
<tr class="separator:aa3b5c8c30850e1d45da44db27052452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8a17dc329db008d3e1f2d4990a1d489b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a17dc329db008d3e1f2d4990a1d489b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a8a17dc329db008d3e1f2d4990a1d489b">operator=</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a8a17dc329db008d3e1f2d4990a1d489b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:adc2b97c3f4ae27b2eae918c9cd473c95"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#adc2b97c3f4ae27b2eae918c9cd473c95">Size</a> () const</td></tr>
<tr class="separator:adc2b97c3f4ae27b2eae918c9cd473c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3cf3f42fbcd6542aa481c9adbc44bf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a0d3cf3f42fbcd6542aa481c9adbc44bf">GetSize</a> () const</td></tr>
<tr class="separator:a0d3cf3f42fbcd6542aa481c9adbc44bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe42665729da6846e2e8e6e74c80f8f3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#abe42665729da6846e2e8e6e74c80f8f3">GetNumberOfElements</a> () const</td></tr>
<tr class="separator:abe42665729da6846e2e8e6e74c80f8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a80fb24cc718c9ff560c15d4594255d96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a80fb24cc718c9ff560c15d4594255d96">SetSize</a> (unsigned int sz, bool destroyExistingData=true)</td></tr>
<tr class="separator:a80fb24cc718c9ff560c15d4594255d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad7db5e21cbe3b9df60231c2ed02d8ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ad7db5e21cbe3b9df60231c2ed02d8ab9">Reserve</a> (<a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">ElementIdentifier</a> size)</td></tr>
<tr class="separator:ad7db5e21cbe3b9df60231c2ed02d8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a27e5f59cff19781f91c44d61d0cec98e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a27e5f59cff19781f91c44d61d0cec98e">operator--</a> ()</td></tr>
<tr class="separator:a27e5f59cff19781f91c44d61d0cec98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8b981c9e141380c475788de159dcdad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a8b981c9e141380c475788de159dcdad3">operator++</a> ()</td></tr>
<tr class="separator:a8b981c9e141380c475788de159dcdad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4d2841f75df038a47e38e6cc160f1a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a4d2841f75df038a47e38e6cc160f1a00">operator--</a> (int)</td></tr>
<tr class="separator:a4d2841f75df038a47e38e6cc160f1a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a5d643a6d87d591c6fa257313d165b738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a5d643a6d87d591c6fa257313d165b738">operator++</a> (int)</td></tr>
<tr class="separator:a5d643a6d87d591c6fa257313d165b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad0107cab1e45da18ce168a0c1d9dba15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad0107cab1e45da18ce168a0c1d9dba15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ad0107cab1e45da18ce168a0c1d9dba15">operator-=</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:ad0107cab1e45da18ce168a0c1d9dba15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae46e11fea0d20546b1533c7250e43177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ae46e11fea0d20546b1533c7250e43177">operator-=</a> (TValue s)</td></tr>
<tr class="separator:ae46e11fea0d20546b1533c7250e43177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acf6324fa55da836509a78a605cbfe769"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf6324fa55da836509a78a605cbfe769"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#acf6324fa55da836509a78a605cbfe769">operator+=</a> (const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:acf6324fa55da836509a78a605cbfe769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac9b7d002d458b4ae62ac4ffa377d4d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ac9b7d002d458b4ae62ac4ffa377d4d3b">operator+=</a> (TValue s)</td></tr>
<tr class="separator:ac9b7d002d458b4ae62ac4ffa377d4d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab6c69847e6e2c5261fb03b12a6ceb4fb"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </td></tr>
<tr class="memitem:ab6c69847e6e2c5261fb03b12a6ceb4fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ab6c69847e6e2c5261fb03b12a6ceb4fb">operator+=</a> (<a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;rhs)</td></tr>
<tr class="separator:ab6c69847e6e2c5261fb03b12a6ceb4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ad1ae55a3efffe35214ca9c96ad07d5c2"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </td></tr>
<tr class="memitem:ad1ae55a3efffe35214ca9c96ad07d5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ad1ae55a3efffe35214ca9c96ad07d5c2">operator-=</a> (<a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;rhs)</td></tr>
<tr class="separator:ad1ae55a3efffe35214ca9c96ad07d5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af680634fef8654fadc537972e9a5e63d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af680634fef8654fadc537972e9a5e63d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#af680634fef8654fadc537972e9a5e63d">operator*=</a> (T s)</td></tr>
<tr class="separator:af680634fef8654fadc537972e9a5e63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a700ddbbf8e11ea07e1cd708f30918867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a700ddbbf8e11ea07e1cd708f30918867">operator*=</a> (TValue s)</td></tr>
<tr class="separator:a700ddbbf8e11ea07e1cd708f30918867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa637cc75e1468c35b27dd77c30bd4ccc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa637cc75e1468c35b27dd77c30bd4ccc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#aa637cc75e1468c35b27dd77c30bd4ccc">operator/=</a> (T s)</td></tr>
<tr class="separator:aa637cc75e1468c35b27dd77c30bd4ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aca3d2a5d6636b217aa753cf7cdd9c29a"><td class="memItemLeft" align="right" valign="top">TValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#aca3d2a5d6636b217aa753cf7cdd9c29a">m_Data</a></td></tr>
<tr class="separator:aca3d2a5d6636b217aa753cf7cdd9c29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d4bec3e14933f156745569c63af498"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a27d4bec3e14933f156745569c63af498">m_LetArrayManageMemory</a> { true }</td></tr>
<tr class="separator:a27d4bec3e14933f156745569c63af498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2cbe68db8cc4fa5ec1ef3ec1fb2f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">ElementIdentifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a4a2cbe68db8cc4fa5ec1ef3ec1fb2f7f">m_NumElements</a> { 0 }</td></tr>
<tr class="separator:a4a2cbe68db8cc4fa5ec1ef3ec1fb2f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af627f6540c50a2946a297dd79b760e5a"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 &gt; </td></tr>
<tr class="memitem:af627f6540c50a2946a297dd79b760e5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeMultiplied.html">Details::op::CanBeMultiplied</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Mult &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#af627f6540c50a2946a297dd79b760e5a">operator*</a> (TExpr1 const &amp;lhs, TExpr2 const &amp;rhs)</td></tr>
<tr class="separator:af627f6540c50a2946a297dd79b760e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af514f3340c26a47c5520f4b27879df56"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 &gt; </td></tr>
<tr class="memitem:af514f3340c26a47c5520f4b27879df56"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeAddedOrSubtracted.html">Details::op::CanBeAddedOrSubtracted</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Plus &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#af514f3340c26a47c5520f4b27879df56">operator+</a> (TExpr1 const &amp;lhs, TExpr2 const &amp;rhs)</td></tr>
<tr class="separator:af514f3340c26a47c5520f4b27879df56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ec00afcef093183740c958eed9961a"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 &gt; </td></tr>
<tr class="memitem:a40ec00afcef093183740c958eed9961a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeAddedOrSubtracted.html">Details::op::CanBeAddedOrSubtracted</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Sub &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a40ec00afcef093183740c958eed9961a">operator-</a> (TExpr1 const &amp;lhs, TExpr2 const &amp;rhs)</td></tr>
<tr class="separator:a40ec00afcef093183740c958eed9961a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72286aa84b3cfffd347fe5c5266c2a05"><td class="memTemplParams" colspan="2">template&lt;typename TExpr1 , typename TExpr2 &gt; </td></tr>
<tr class="memitem:a72286aa84b3cfffd347fe5c5266c2a05"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeDivided.html">Details::op::CanBeDivided</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Div &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a72286aa84b3cfffd347fe5c5266c2a05">operator/</a> (TExpr1 const &amp;lhs, TExpr2 const &amp;rhs)</td></tr>
<tr class="separator:a72286aa84b3cfffd347fe5c5266c2a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Serialization</div></td></tr>
<tr class="memitem:ad38e295bac6f8e926d13ab8bd5ec4b3f"><td class="memTemplParams" colspan="2">template&lt;typename TValue &gt; </td></tr>
<tr class="memitem:ad38e295bac6f8e926d13ab8bd5ec4b3f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#ad38e295bac6f8e926d13ab8bd5ec4b3f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; TValue &gt; &amp;arr)</td></tr>
<tr class="separator:ad38e295bac6f8e926d13ab8bd5ec4b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard compliance functions</div></td></tr>
<tr class="memitem:a648790605a6460b4fc2c164ecd09e09c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a648790605a6460b4fc2c164ecd09e09c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classitk_1_1VariableLengthVector.html#a648790605a6460b4fc2c164ecd09e09c">swap</a> (<a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;l_, <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;r_) noexcept</td></tr>
<tr class="separator:a648790605a6460b4fc2c164ecd09e09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents an array whose length can be defined at run-time. </p>
<p>This class is templated over the data type. This data-type is meant to be a scalar, such as float, double etc...</p>
<dl class="section note"><dt>Note</dt><dd>ITK itself provides several classes that can serve as <code>Arrays</code>. <ul>
<li><a class="el" href="classitk_1_1FixedArray.html" title="Simulate a standard C array with copy semantics.">FixedArray</a> - Compile time fixed length arrays that's intended to represent an enumerated collection of <code>n</code> entities.</li>
</ul>
<ul>
<li><a class="el" href="classitk_1_1Array.html" title="Array class with size defined at construction time.">Array</a> - Run time resizeable array that is intended to hold a collection of <code>n</code> entities</li>
</ul>
<ul>
<li><a class="el" href="classitk_1_1Vector.html" title="A templated class holding a n-Dimensional vector.">Vector</a> - Compile time fixed length array that is intended to hold a collection of <code>n</code> data types. A vector usually has a mathematical meaning. It should only be used when mathematical operations such as addition, multiplication by a scalar, product etc make sense.</li>
</ul>
<ul>
<li><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a> - Run time array that is intended to hold a collection of scalar data types. Again, it should be used only when mathematical operations on it are relevant. If not, use an <a class="el" href="classitk_1_1Array.html" title="Array class with size defined at construction time.">Array</a>.</li>
</ul>
<ul>
<li><a class="el" href="classitk_1_1Point.html" title="A templated class holding a geometric point in n-Dimensional space.">Point</a> - Represents the spatial coordinates of a spatial location. Operators on <a class="el" href="classitk_1_1Point.html" title="A templated class holding a geometric point in n-Dimensional space.">Point</a> reflect geometrical concepts.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>For the reasons listed above, you cannot instantiate</dt><dd><div class="fragment"><div class="line">VariableLengthVector&lt; bool &gt; </div>
</div><!-- fragment -->.</dd></dl>
<dl class="section user"><dt></dt><dd>Design Considerations: We do not derive from <code>vnl_vector</code> to avoid being limited by the explicit template instantiations of vnl_vector and other hacks that vnl folks have been forced to use.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This work is part of the National Alliance for Medical <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">Image</a> Computing (NAMIC), funded by the National Institutes of Health through the NIH Roadmap for Medical Research, Grant U54 EB005149.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1CovariantVector.html" title="A templated class holding a n-Dimensional covariant vector.">CovariantVector</a> </dd>
<dd>
<a class="el" href="classitk_1_1SymmetricSecondRankTensor.html" title="Represent a symmetric tensor of second rank.">SymmetricSecondRankTensor</a> </dd>
<dd>
<a class="el" href="classitk_1_1RGBPixel.html" title="Represent Red, Green and Blue components for color images.">RGBPixel</a> </dd>
<dd>
<a class="el" href="classitk_1_1DiffusionTensor3D.html" title="Represent a diffusion tensor as used in DTI images.">DiffusionTensor3D</a></dd></dl>
<dl class="section user"><dt>ITK Sphinx Examples:</dt><dd><ul>
<li><a href="https://itk.org/ITKExamples">All ITK Sphinx Examples</a></li>
</ul>
<ul>
<li><a href="https://itk.org/ITKExamples/src/Core/Common/VariableLengthVector/Documentation.html">Variable Length Vector</a></li>
</ul>
</dd></dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If <code>m_LetArrayManageMemory</code> is true, <code>m_Data</code> is deletable (whether it's null or pointing to something with no elements. i.e. <code>m_NumElements</code> may be 0 and yet <code>m_Data</code> may be not null.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkConstantBoundaryCondition_8h_source.html#l00028">28</a> of file <a class="el" href="itkConstantBoundaryCondition_8h_source.html">itkConstantBoundaryCondition.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af5001bcf6a9e8567fa185610430a5e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5001bcf6a9e8567fa185610430a5e90">&#9670;&nbsp;</a></span>ComponentType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1VariableLengthVector.html#af5001bcf6a9e8567fa185610430a5e90">itk::VariableLengthVector::ComponentType</a> =  TValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00319">319</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a3405e9cd0ebe9c0dd741d5f5911a7b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3405e9cd0ebe9c0dd741d5f5911a7b8c">&#9670;&nbsp;</a></span>ElementIdentifier</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">itk::VariableLengthVector::ElementIdentifier</a> =  unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef used to indicate the number of elements in the vector </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00324">324</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="ad13766c0f231fc7cdaceeebbf9ba06c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13766c0f231fc7cdaceeebbf9ba06c6">&#9670;&nbsp;</a></span>RealValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1VariableLengthVector.html#ad13766c0f231fc7cdaceeebbf9ba06c6">itk::VariableLengthVector::RealValueType</a> =  typename <a class="el" href="classitk_1_1NumericTraits.html">NumericTraits</a>&lt;<a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">ValueType</a>&gt;::RealType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00320">320</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a2400a451d7131001088023ffd857f1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2400a451d7131001088023ffd857f1fa">&#9670;&nbsp;</a></span>Self</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">itk::VariableLengthVector::Self</a> =  <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00321">321</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a7b6111db02041ab7eb748c67f26a48df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6111db02041ab7eb748c67f26a48df">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">itk::VariableLengthVector::ValueType</a> =  TValue</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The element type stored at each location in the <a class="el" href="classitk_1_1Array.html" title="Array class with size defined at construction time.">Array</a>. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00318">318</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2051f13f8bcfb3451344b3b02c01b7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2051f13f8bcfb3451344b3b02c01b7c5">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. It is created with an empty array it has to be allocated later by assignment, <code><a class="el" href="classitk_1_1VariableLengthVector.html#a8610c53a2496c1e8d7c105c430a0b0ec">SetSize()</a></code> or <code><a class="el" href="classitk_1_1VariableLengthVector.html#ad7db5e21cbe3b9df60231c2ed02d8ab9">Reserve()</a></code>. </p><dl class="section post"><dt>Postcondition</dt><dd><code>m_Data</code> is null </dd>
<dd>
<code>m_NumElements</code> is 0 </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd></dl>

</div>
</div>
<a id="ac092e28bcbe220ace0f1c6273a2251ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac092e28bcbe220ace0f1c6273a2251ab">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with size. <a class="el" href="structitk_1_1Size.html" title="Represent a n-dimensional size (bounds) of a n-dimensional image.">Size</a> can only be changed by assignment, <code><a class="el" href="classitk_1_1VariableLengthVector.html#a8610c53a2496c1e8d7c105c430a0b0ec">SetSize()</a></code> or <code><a class="el" href="classitk_1_1VariableLengthVector.html#ad7db5e21cbe3b9df60231c2ed02d8ab9">Reserve()</a></code>. </p><dl class="section post"><dt>Postcondition</dt><dd><code>m_Data</code> is not null and points to an array of <code>m_NumElements</code>, even if <code>m_NumElements</code> is 0 </dd>
<dd>
values are left uninitialized. </dd>
<dd>
<code>m_NumElements</code> is <code>dimension</code> </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd></dl>

</div>
</div>
<a id="a7548854c7542959b4572abb96a3ca302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7548854c7542959b4572abb96a3ca302">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">ValueType</a> *&#160;</td>
          <td class="paramname"><em>datain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>LetArrayManageMemory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that initializes array with contents from a user supplied buffer. The pointer to the buffer and the length is specified. By default, the array does not manage the memory of the buffer. It merely points to that location and it is the user's responsibility to delete it. If <code>LetArrayManageMemory</code> is true, then this class will free the memory when this object is destroyed.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>m_Data == data</code> </dd>
<dd>
values are left unmodified </dd>
<dd>
<code>m_NumElements == sz</code> </dd>
<dd>
<code>m_LetArrayManageMemory == LetArrayManageMemory</code> </dd></dl>

</div>
</div>
<a id="a6328ba722ccf04a948eb71f84b174e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6328ba722ccf04a948eb71f84b174e52">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html#a7b6111db02041ab7eb748c67f26a48df">ValueType</a> *&#160;</td>
          <td class="paramname"><em>datain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>LetArrayManageMemory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that initializes array with contents from a user supplied buffer. The pointer to the buffer and the length is specified. By default, the array does not manage the memory of the buffer. It merely points to that location and it is the user's responsibility to delete it. If <code>LetArrayManageMemory</code> is true, then this class will free the memory when this object is destroyed.</p>
<dl class="section warning"><dt>Warning</dt><dd>This overload receives a non-modiable array, and yet it will let the end-user try to modify it through <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> interface. Use this constructor with care as this may lead to undefined behaviour. Prefer using <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a>&lt;const TValue&gt;</code> instead of <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a>&lt;TValue&gt;</code> in case we which to use this constructor.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>m_Data == data</code> </dd>
<dd>
values are left unmodified </dd>
<dd>
<code>m_NumElements == sz</code> </dd>
<dd>
<code>m_LetArrayManageMemory == LetArrayManageMemory</code> </dd></dl>

</div>
</div>
<a id="a3556c3d6e08b14e372677ac893de9262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3556c3d6e08b14e372677ac893de9262">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. The reason why the copy constructor and the assignment operator are templated is that it will allow implicit casts to be performed. For instance: </p><div class="fragment"><div class="line">VariableLengthVector&lt; int &gt; vI;</div>
<div class="line">VariableLengthVector&lt; float &gt; vF( vI );</div>
<div class="line">or <span class="keywordflow">for</span> instance vF = <span class="keyword">static_cast&lt;</span> VariableLengthVector&lt; float &gt; <span class="keyword">&gt;</span>( vI );</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>However that static casting in this way will imply the allocation of a temporary <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code>. Prefer to directly use the assignment converting operator in code where uses of <code>static_cast&lt;&gt;</code> would be required.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>m_Data</code> is not null and points to an array of <code>m_NumElements</code>, if <code>m_NumElements</code> is 0, otherwise it's null. </dd>
<dd>
values are left uninitialized. </dd>
<dd>
<code>m_NumElements</code> is <code>v.GetSize()</code> </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00400">400</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">References <a class="el" href="itkVariableLengthVector_8h_source.html#l00590">Size()</a>.</p>

</div>
</div>
<a id="a9a8bb674772c4367543f3fc96a77c8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8bb674772c4367543f3fc96a77c8d2">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Overrides the default non-templated copy constructor that the compiler provides. </p><dl class="section post"><dt>Postcondition</dt><dd><code>m_Data</code> is not null and points to an array of <code>m_NumElements</code>, if <code>m_NumElements</code> is 0, otherwise it's null. </dd>
<dd>
values are left uninitialized. </dd>
<dd>
<code>m_NumElements</code> is <code>v.GetSize()</code> </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd></dl>

</div>
</div>
<a id="a68b4ece405c3ea70fba0fa334b7d3130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b4ece405c3ea70fba0fa334b7d3130">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++11 Move Constructor. </p><dl class="section post"><dt>Postcondition</dt><dd><code>v</code> is destructible and assignable. </dd>
<dd>
<code>m_NumElements == 0</code> </dd>
<dd>
<code>m_LetArrayManageMemory == true</code> </dd>
<dd>
<code>m_Data == nullptr</code> </dd>
<dd>
Built object contains old <code>v</code> data. </dd></dl>

</div>
</div>
<a id="a70f1f29e49f5371c71db623d20a33b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f1f29e49f5371c71db623d20a33b30">&#9670;&nbsp;</a></span>VariableLengthVector() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::VariableLengthVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor from an Expression Template vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TExpr1</td><td>Type of the left sub-expression </td></tr>
    <tr><td class="paramname">TExpr2</td><td>Type of the right sub-expression </td></tr>
    <tr><td class="paramname">TBinaryOp</td><td>Binary <a class="el" href="classOperation.html">Operation</a> to apply to both sub-expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Non evaluated Expression Template.</td></tr>
  </table>
  </dd>
</dl>
<p>Builds the new <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> with an expression template. The code loops over all components from the template expression, and evaluates them on the fly to fill the content of the new vector.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>m_Data</code> is not null and points to an array of <code>m_NumElements</code>, even if <code>m_NumElements</code> is 0 </dd>
<dd>
<code>*this == rhs</code> </dd>
<dd>
<code>m_NumElements</code> is <code>rhs.GetSize()</code> </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd></dl>

</div>
</div>
<a id="a36bec5f9a30ef12f70983f1abd2755ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bec5f9a30ef12f70983f1abd2755ef">&#9670;&nbsp;</a></span>~VariableLengthVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::~VariableLengthVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This destructor is not virtual for performance reasons. However, this means that subclasses cannot allocate memory. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a50e65a3ca102fa181e871232d0a00b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e65a3ca102fa181e871232d0a00b5c">&#9670;&nbsp;</a></span>AllocateElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TValue* itk::VariableLengthVector::AllocateElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">ElementIdentifier</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate memory of certain size and return it. </p><dl class="section return"><dt>Returns</dt><dd>a non-null pointer to an array of <code>size</code> elements (0 is a valid parameter). </dd></dl>

</div>
</div>
<a id="a05965b2457247f3ff3a376353c65c0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05965b2457247f3ff3a376353c65c0a6">&#9670;&nbsp;</a></span>DestroyExistingData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::DestroyExistingData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy data that is allocated internally, if <code>LetArrayManageMemory</code> is true. </p>

</div>
</div>
<a id="ad76bf30dc0eb546a95f69c7741585aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76bf30dc0eb546a95f69c7741585aa3">&#9670;&nbsp;</a></span>FastAssign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::FastAssign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast Assignment. </p><dl class="section pre"><dt>Precondition</dt><dd><code>m_LetArrayManageMemory</code> is true: the <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> is not a proxy, checked with an assertion. Call <code>SetSize(<a class="el" href="classitk_1_1VariableLengthVector.html#a0d3cf3f42fbcd6542aa481c9adbc44bf">GetSize()</a>, NeverReallocate(), DumpOldValues())</code> to ensure a vector is not a proxy anymore. </dd>
<dd>
current size is identical to the one from the right hand side operand, checked with an assertion. </dd>
<dd>
Doesn't not support empty vectors. </dd></dl>

</div>
</div>
<a id="aea82d1c7a0680533fb73cc4ab1af4c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea82d1c7a0680533fb73cc4ab1af4c7d">&#9670;&nbsp;</a></span>Fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::Fill </td>
          <td>(</td>
          <td class="paramtype">TValue const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all the elements of the array to the specified value. </p><dl class="section pre"><dt>Precondition</dt><dd>This function may be called on empty vectors, it's a no-op. </dd></dl>

<p class="reference">Referenced by <a class="el" href="itkMaskImageFilter_8h_source.html#l00276">itk::MaskImageFilter&lt; TInputImage, TMaskImage, TOutputImage &gt;::CheckOutsideValue()</a>, <a class="el" href="itkLinearInterpolateImageFunction_8h_source.html#l00512">itk::LinearInterpolateImageFunction&lt; TInputImage, TCoordRep &gt;::MakeZeroInitializer()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00096">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::max()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00105">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::min()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00132">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::NonpositiveMin()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00123">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::OneValue()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00202">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::SetLength()</a>, and <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00114">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::ZeroValue()</a>.</p>

</div>
</div>
<a id="a215998cc438efbe863609c19cc29feb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215998cc438efbe863609c19cc29feb8">&#9670;&nbsp;</a></span>GetDataPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TValue* itk::VariableLengthVector::GetDataPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00765">765</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="itkMetaArrayWriter_8h_source.html#l00109">itk::MetaArrayWriter::SetInput()</a>.</p>

</div>
</div>
<a id="ae19043c11455fa9f7a7329a9504f5b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19043c11455fa9f7a7329a9504f5b7f">&#9670;&nbsp;</a></span>GetElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TValue&amp; itk::VariableLengthVector::GetElement </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one element </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00614">614</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a3592a6f501ea61701068eec95a278164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3592a6f501ea61701068eec95a278164">&#9670;&nbsp;</a></span>GetNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#ad13766c0f231fc7cdaceeebbf9ba06c6">RealValueType</a> itk::VariableLengthVector::GetNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns vector's Euclidean Norm <br  />
 </p>

<p class="reference">Referenced by <a class="el" href="itkDefaultConvertPixelTraits_8h_source.html#l00239">itk::DefaultConvertPixelTraits&lt; VariableLengthVector&lt; VComponent &gt; &gt;::GetScalarValue()</a>.</p>

</div>
</div>
<a id="abe42665729da6846e2e8e6e74c80f8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe42665729da6846e2e8e6e74c80f8f3">&#9670;&nbsp;</a></span>GetNumberOfElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::VariableLengthVector::GetNumberOfElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements in the <a class="el" href="classitk_1_1Array.html" title="Array class with size defined at construction time.">Array</a> <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00600">600</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a0d3cf3f42fbcd6542aa481c9adbc44bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3cf3f42fbcd6542aa481c9adbc44bf">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::VariableLengthVector::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements in the <a class="el" href="classitk_1_1Array.html" title="Array class with size defined at construction time.">Array</a> <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00595">595</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="itkMaskImageFilter_8h_source.html#l00276">itk::MaskImageFilter&lt; TInputImage, TMaskImage, TOutputImage &gt;::CheckOutsideValue()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00211">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::GetLength()</a>, <a class="el" href="itkRecursiveSeparableImageFilter_8h_source.html#l00195">itk::RecursiveSeparableImageFilter&lt; TInputImage, TInputImage &gt;::MathEMAMAMAM()</a>, <a class="el" href="itkRecursiveSeparableImageFilter_8h_source.html#l00233">itk::RecursiveSeparableImageFilter&lt; TInputImage, TInputImage &gt;::MathSMAMAMAM()</a>, <a class="el" href="itkVariableLengthVector_8h_source.html#l00861">operator+=()</a>, and <a class="el" href="itkVariableLengthVector_8h_source.html#l00828">operator-=()</a>.</p>

</div>
</div>
<a id="afedda7a4bb6f16e673f595096963c797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedda7a4bb6f16e673f595096963c797">&#9670;&nbsp;</a></span>GetSquaredNorm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#ad13766c0f231fc7cdaceeebbf9ba06c6">RealValueType</a> itk::VariableLengthVector::GetSquaredNorm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns vector's squared Euclidean Norm <br  />
 </p>

</div>
</div>
<a id="a0a8ccb4bd105d3bd09ea90133966ce22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8ccb4bd105d3bd09ea90133966ce22">&#9670;&nbsp;</a></span>IsAProxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::VariableLengthVector::IsAProxy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>letArrayManageMemory getter. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01001">1001</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="af4f2a9e5b53188ea4a0feec328c0e8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f2a9e5b53188ea4a0feec328c0e8c2">&#9670;&nbsp;</a></span>ITK_UNEQUAL_OPERATOR_MEMBER_FUNCTION()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">itk::VariableLengthVector::ITK_UNEQUAL_OPERATOR_MEMBER_FUNCTION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af680634fef8654fadc537972e9a5e63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af680634fef8654fadc537972e9a5e63d">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator*= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply each element of the vector by a scalar 's'. The scalar value is cast to the current vector element type prior to multiplication. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00935">935</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a700ddbbf8e11ea07e1cd708f30918867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700ddbbf8e11ea07e1cd708f30918867">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator*= </td>
          <td>(</td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply each element of the vector by a scalar 's'. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00950">950</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a8b981c9e141380c475788de159dcdad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b981c9e141380c475788de159dcdad3">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix operator that adds 1 to each element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00785">785</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a5d643a6d87d591c6fa257313d165b738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d643a6d87d591c6fa257313d165b738">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> itk::VariableLengthVector::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix operator that adds 1 to each element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00809">809</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="acf6324fa55da836509a78a605cbfe769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6324fa55da836509a78a605cbfe769">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Element-wise addition of vector 'v' to the current vector. The vectors do not have to have the same element type. The input vector elements are cast to the current vector element type before the addition is performed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For efficiency, the length of the vectors is not checked; they are assumed to have the same length. </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00861">861</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">References <a class="el" href="itkVariableLengthVector_8h_source.html#l00595">GetSize()</a>.</p>

</div>
</div>
<a id="ac9b7d002d458b4ae62ac4ffa377d4d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b7d002d458b4ae62ac4ffa377d4d3b">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator+= </td>
          <td>(</td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add scalar 's' to each element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00874">874</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="ab6c69847e6e2c5261fb03b12a6ceb4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c69847e6e2c5261fb03b12a6ceb4fb">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compound addition operator with a expression template vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TExpr1</td><td>Type of the left sub-expression </td></tr>
    <tr><td class="paramname">TExpr2</td><td>Type of the right sub-expression </td></tr>
    <tr><td class="paramname">TBinaryOp</td><td>Binary <a class="el" href="classOperation.html">Operation</a> to apply to both sub-expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Non evaluated Expression Template.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="classitk_1_1VariableLengthVector.html#adc2b97c3f4ae27b2eae918c9cd473c95">Size()</a> == rhs.Size()</code>, checked with an assertion </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The elements of the expression template are evaluated one by one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00895">895</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a74e3a1078247b3f8fe6e61ea1f54e64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e3a1078247b3f8fe6e61ea1f54e64f">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Negates each vector element. </p><dl class="section warning"><dt>Warning</dt><dd>This operator has a non standard semantics. Instead of returning a new <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code>, it modifies the current object. </dd></dl>

</div>
</div>
<a id="a27e5f59cff19781f91c44d61d0cec98e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e5f59cff19781f91c44d61d0cec98e">&#9670;&nbsp;</a></span>operator--() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prefix operator that subtracts 1 from each element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00773">773</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a4d2841f75df038a47e38e6cc160f1a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2841f75df038a47e38e6cc160f1a00">&#9670;&nbsp;</a></span>operator--() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> itk::VariableLengthVector::operator-- </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Postfix operator that subtracts 1 from each element of the vector. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00798">798</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="ad0107cab1e45da18ce168a0c1d9dba15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0107cab1e45da18ce168a0c1d9dba15">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Element-wise subtraction of vector 'v' from the current vector. The vectors do not have to have the same element type. The input vector elements are cast to the current vector element type before the subtraction is performed.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For efficiency, the length of the vectors is not checked; they are assumed to have the same length. </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00828">828</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">References <a class="el" href="itkVariableLengthVector_8h_source.html#l00595">GetSize()</a>.</p>

</div>
</div>
<a id="ae46e11fea0d20546b1533c7250e43177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46e11fea0d20546b1533c7250e43177">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator-= </td>
          <td>(</td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract scalar 's' from each element of the current vector. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00841">841</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="ad1ae55a3efffe35214ca9c96ad07d5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ae55a3efffe35214ca9c96ad07d5c2">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compound subtraction operator with a expression template vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TExpr1</td><td>Type of the left sub-expression </td></tr>
    <tr><td class="paramname">TExpr2</td><td>Type of the right sub-expression </td></tr>
    <tr><td class="paramname">TBinaryOp</td><td>Binary <a class="el" href="classOperation.html">Operation</a> to apply to both sub-expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Non evaluated Expression Template.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code><a class="el" href="classitk_1_1VariableLengthVector.html#adc2b97c3f4ae27b2eae918c9cd473c95">Size()</a> == rhs.Size()</code>, checked with an assertion </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The elements of the expression template are evaluated one by one. </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00917">917</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="aa637cc75e1468c35b27dd77c30bd4ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa637cc75e1468c35b27dd77c30bd4ccc">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator/= </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide vector elements by a scalar 's'. The vector does not have to have the same element type as the scalar type. Both the scalar and vector elements are cast to the RealValueType prior to division, and the result is cast to the ValueType. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00968">968</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a2932f230d47190fb85da909755f13eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2932f230d47190fb85da909755f13eb1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy-Assignment operator. </p><dl class="section note"><dt>Note</dt><dd>Ensures a <em>String Exception Guarantee</em>: resists to self-assignment, and no changes are made if memory cannot be allocated to hold the new elements. This is expecting <code>TValue</code> assignment is a <code>noexcept</code> operation.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if called on a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> proxy, the referenced values are left unchanged. </dd>
<dd>
<code>m_Data</code> is not null and points to an array of <code>m_NumElements</code>, if <code>m_NumElements</code> is not 0. <code>m_Data</code> may be null otherwise (an empty vector is assigned into another empty vector) </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd>
<dd>
<code><a class="el" href="classitk_1_1VariableLengthVector.html#a0d3cf3f42fbcd6542aa481c9adbc44bf">GetSize()</a> == v.GetSize()</code> </dd>
<dd>
<code>*this == v</code> </dd></dl>

</div>
</div>
<a id="a8a17dc329db008d3e1f2d4990a1d489b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a17dc329db008d3e1f2d4990a1d489b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converting assignment operator. </p><dl class="section note"><dt>Note</dt><dd>Ensures a <em>String Exception Guarantee</em>: resists to self-assignment, and no changes are made if memory cannot be allocated to hold the new elements. This presumes <code>TValue</code> assignment is a <code>noexcept</code> operation.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>if called on a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> proxy, the referenced values are left unchanged. </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd>
<dd>
<code><a class="el" href="classitk_1_1VariableLengthVector.html#a0d3cf3f42fbcd6542aa481c9adbc44bf">GetSize()</a> == v.GetSize()</code>, modulo precision </dd>
<dd>
<code>*this == v</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00530">530</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">References <a class="el" href="itkVariableLengthVector_8h_source.html#l00590">Size()</a>.</p>

</div>
</div>
<a id="a1fc0bfa5d5520901b5f69288b4acc5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc0bfa5d5520901b5f69288b4acc5e4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>C++11 Move assignment operator. </p><dl class="section pre"><dt>Precondition</dt><dd><code>v</code> shall not be the same as the current object </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>v</code> is destructible and assignable. </dd>
<dd>
<code>m_NumElements == 0</code> </dd>
<dd>
<code>m_LetArrayManageMemory == true</code> </dd>
<dd>
<code>m_Data == nullptr</code> </dd>
<dd>
Current object contains old <code>v</code> data. </dd></dl>

</div>
</div>
<a id="a42a48440caf7a5dfe57b44938139d966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a48440caf7a5dfe57b44938139d966">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator= </td>
          <td>(</td>
          <td class="paramtype">TValue const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator from a numeric value. </p><dl class="section pre"><dt>Precondition</dt><dd>This assumes <code>m_LetArrayManageMemory</code> is true, but it is unchecked. If this operator is called on a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> proxy, referenced values will be overwritten. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Elements in <code>[m_Data, m_Data+GetSize())</code> will be equal to <code>v</code>, modulo precision </dd></dl>

</div>
</div>
<a id="af806aa3e3d76bdb4a1e02b8a696a2834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af806aa3e3d76bdb4a1e02b8a696a2834">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 , typename TBinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a>&amp; itk::VariableLengthVector::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, TBinaryOp &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment from an Expression Template vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TExpr1</td><td>Type of the left sub-expression </td></tr>
    <tr><td class="paramname">TExpr2</td><td>Type of the right sub-expression </td></tr>
    <tr><td class="paramname">TBinaryOp</td><td>Binary <a class="el" href="classOperation.html">Operation</a> to apply to both sub-expressions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>Non evaluated Expression Template.</td></tr>
  </table>
  </dd>
</dl>
<p>Resets the new <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> with an expression template. The code loops over all components from the template expression, and evaluates them on the fly to fill the content of the current vector.</p>
<dl class="section post"><dt>Postcondition</dt><dd>if called on a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> proxy, the referenced values are left unchanged. </dd>
<dd>
<code>m_Data</code> is not null and points to an array of <code>m_NumElements</code>, if <code>m_NumElements</code> is not 0. <code>m_Data</code> may be null otherwise (an empty vector is assigned into another empty vector) </dd>
<dd>
<code>m_LetArrayManageMemory</code> is true </dd>
<dd>
<code><a class="el" href="classitk_1_1VariableLengthVector.html#a0d3cf3f42fbcd6542aa481c9adbc44bf">GetSize()</a> == rhs.GetSize()</code> </dd>
<dd>
<code>*this == rhs</code> </dd></dl>

</div>
</div>
<a id="a4dc050a6c37fbb72c6153c5144491d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc050a6c37fbb72c6153c5144491d28">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::VariableLengthVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d85366b1efcdc7f0bf0e1a591769190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d85366b1efcdc7f0bf0e1a591769190">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TValue&amp; itk::VariableLengthVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return reference to the element at specified index. No range checking. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00607">607</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="afc51511d476c4c215c88dde29789795a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc51511d476c4c215c88dde29789795a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TValue&amp; itk::VariableLengthVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return reference to the element at specified index. No range checking. </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00610">610</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="ad7db5e21cbe3b9df60231c2ed02d8ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7db5e21cbe3b9df60231c2ed02d8ab9">&#9670;&nbsp;</a></span>Reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::Reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">ElementIdentifier</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserves memory of a certain length. </p><pre class="fragment">If the array already contains data, the existing data is copied over and
new space is allocated, if necessary. If the length to reserve is less
than the current number of elements, then an appropriate number of elements
are discarded.
\post \c m_Data is not null and can hold \c size elements.
\post \c m_LetArrayManageMemory may be left unchanged if there already are
enough elements.

\note You may prefer instead
`SetSize(N, DontShrinkToFit(), KeepOldValues());` that ensures that the
array is not a proxy at the end of the operation.
</pre> 
</div>
</div>
<a id="a73f2f6ca38a442f2a63edee6b090600d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f2f6ca38a442f2a63edee6b090600d">&#9670;&nbsp;</a></span>SetData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::SetData </td>
          <td>(</td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>datain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>LetArrayManageMemory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the pointer from which the data is imported. If "LetArrayManageMemory" is false, then the application retains the responsibility of freeing the memory for this data. If "LetArrayManageMemory" is true, then this class will free the memory when this object is destroyed. </p><dl class="section warning"><dt>Warning</dt><dd>The size of the new <code>data</code> shall match vector current size. Prefer the other overload. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>old <code>m_Data</code> is deleted iff <code>m_LetArrayManageMemory</code> is true </dd>
<dd>
<code>m_Data == data</code> </dd>
<dd>
<code>m_LetArrayManageMemory ==LetArrayManageMemory</code> </dd>
<dd>
<code><a class="el" href="classitk_1_1VariableLengthVector.html#adc2b97c3f4ae27b2eae918c9cd473c95">Size()</a></code> is left unmodified. </dd></dl>

<p class="reference">Referenced by <a class="el" href="itkMetaArrayReader_8h_source.html#l00208">itk::MetaArrayReader::GetOutput()</a>.</p>

</div>
</div>
<a id="a8d88fa71693d811e58eb1dd01f358e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d88fa71693d811e58eb1dd01f358e36">&#9670;&nbsp;</a></span>SetData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::SetData </td>
          <td>(</td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>datain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>LetArrayManageMemory</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the previous method. In the above method, the size must be separately set prior to using user-supplied data. This introduces an unnecessary allocation step to be performed. This method avoids it and should be used to import data wherever possible to avoid this. Set the pointer from which the data is imported. If "LetArrayManageMemory" is false, then the application retains the responsibility of freeing the memory for this data. If "LetArrayManageMemory" is true, then this class will free the memory when this object is destroyed. </p><dl class="section post"><dt>Postcondition</dt><dd>old <code>m_Data</code> is deleted iff <code>m_LetArrayManageMemory</code> is true </dd>
<dd>
<code>m_Data == data</code> </dd>
<dd>
<code>m_LetArrayManageMemory ==LetArrayManageMemory</code> </dd>
<dd>
<code>m_NumElements == sz</code> </dd></dl>

</div>
</div>
<a id="ae629d9c525c44a8372cff0522195b233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae629d9c525c44a8372cff0522195b233">&#9670;&nbsp;</a></span>SetElement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::SetElement </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set one element </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00621">621</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a80fb24cc718c9ff560c15d4594255d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fb24cc718c9ff560c15d4594255d96">&#9670;&nbsp;</a></span>SetSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::SetSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>destroyExistingData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the size to that given. </p><pre class="fragment">If \c destroyExistingData is \c false:
If the array already contains data, the existing data is copied over and
new space is allocated, if necessary. If the length to reserve is less
than the current number of elements, then an appropriate number of elements
are discarded.
   If \c true, the size is set destructively to the length given. If the
length is different from the current length, existing data will be lost.
The default is \c true. 
</pre> 
<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00674">674</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a8610c53a2496c1e8d7c105c430a0b0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8610c53a2496c1e8d7c105c430a0b0ec">&#9670;&nbsp;</a></span>SetSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TReallocatePolicy , typename TKeepValuesPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::SetSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TReallocatePolicy&#160;</td>
          <td class="paramname"><em>reallocatePolicy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKeepValuesPolicy&#160;</td>
          <td class="paramname"><em>keepValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resizes the vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TReallocatePolicy</td><td>Policy that determines precisely the conditions under which the internal buffer shall be reallocated. It shall inherit from <code><a class="el" href="structitk_1_1VariableLengthVector_1_1AllocateRootPolicy.html">AllocateRootPolicy</a></code>. </td></tr>
    <tr><td class="paramname">TKeepValuesPolicy</td><td>Policy that determines whether old elements shall be kept. It shall inherit from <code><a class="el" href="structitk_1_1VariableLengthVector_1_1KeepValuesRootPolicy.html">KeepValuesRootPolicy</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="itkMaskImageFilter_8h_source.html#l00276">itk::MaskImageFilter&lt; TInputImage, TMaskImage, TOutputImage &gt;::CheckOutsideValue()</a>, <a class="el" href="itkLinearInterpolateImageFunction_8h_source.html#l00512">itk::LinearInterpolateImageFunction&lt; TInputImage, TCoordRep &gt;::MakeZeroInitializer()</a>, <a class="el" href="itkRecursiveSeparableImageFilter_8h_source.html#l00195">itk::RecursiveSeparableImageFilter&lt; TInputImage, TInputImage &gt;::MathEMAMAMAM()</a>, <a class="el" href="itkRecursiveSeparableImageFilter_8h_source.html#l00233">itk::RecursiveSeparableImageFilter&lt; TInputImage, TInputImage &gt;::MathSMAMAMAM()</a>, and <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00202">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::SetLength()</a>.</p>

</div>
</div>
<a id="adc2b97c3f4ae27b2eae918c9cd473c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2b97c3f4ae27b2eae918c9cd473c95">&#9670;&nbsp;</a></span>Size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int itk::VariableLengthVector::Size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of elements in the <a class="el" href="classitk_1_1Array.html" title="Array class with size defined at construction time.">Array</a> <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00590">590</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="itkMeasurementVectorTraits_8h_source.html#l00125">itk::Statistics::MeasurementVectorTraits::Assert()</a>, <a class="el" href="itkDefaultConvertPixelTraits_8h_source.html#l00224">itk::DefaultConvertPixelTraits&lt; VariableLengthVector&lt; VComponent &gt; &gt;::GetNumberOfComponents()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00096">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::max()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00105">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::min()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00132">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::NonpositiveMin()</a>, <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00123">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::OneValue()</a>, <a class="el" href="itkVariableLengthVector_8h_source.html#l01410">operator&lt;&lt;()</a>, <a class="el" href="itkVariableLengthVector_8h_source.html#l00530">operator=()</a>, <a class="el" href="itkMetaArrayWriter_8h_source.html#l00109">itk::MetaArrayWriter::SetInput()</a>, <a class="el" href="itkMeshIOBase_8h_source.html#l00408">itk::MeshIOBase::SetPixelType()</a>, <a class="el" href="itkVariableLengthVector_8h_source.html#l00400">VariableLengthVector()</a>, and <a class="el" href="itkNumericTraitsVariableLengthVectorPixel_8h_source.html#l00114">itk::NumericTraits&lt; VariableLengthVector&lt; T &gt; &gt;::ZeroValue()</a>.</p>

</div>
</div>
<a id="aa3b5c8c30850e1d45da44db27052452c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b5c8c30850e1d45da44db27052452c">&#9670;&nbsp;</a></span>Swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void itk::VariableLengthVector::Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html#a2400a451d7131001088023ffd857f1fa">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps two <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> 's. </p><dl class="section pre"><dt>Precondition</dt><dd>Expects either none of the <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> to act as a proxy, or both, checked with an assertion. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>*this</code> and <code>old</code> contents are swapped. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>other <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> to be swapped with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code><a class="el" href="namespaceitk.html#a444ac331d4dbacc8b8155954cfb8b692">itk::swap()</a></code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l00439">439</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">References <a class="el" href="itkArray_8h_source.html#l00242">itk::swap()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af627f6540c50a2946a297dd79b760e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af627f6540c50a2946a297dd79b760e5a">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeMultiplied.html">Details::op::CanBeMultiplied</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Mult &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">TExpr1 const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExpr2 const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication between a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> and a scalar. This operation is generic and takes one array and one number (on either side). </p><dl class="section return"><dt>Returns</dt><dd>an expression template proxy object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>As no allocation will be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>mpl::IsArray&lt;&gt;</code> to know the exact array types recognized as <em>array</em> by this traits </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01330">1330</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="af514f3340c26a47c5520f4b27879df56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af514f3340c26a47c5520f4b27879df56">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeAddedOrSubtracted.html">Details::op::CanBeAddedOrSubtracted</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Plus &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">TExpr1 const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExpr2 const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition involving a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code>. This operation is generic and takes:</p><ul>
<li>two arrays,</li>
<li>or one array and one number (on either side) <dl class="section return"><dt>Returns</dt><dd>an expression template proxy object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>As no allocation will be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>mpl::IsArray&lt;&gt;</code> to know the exact array types recognized as <em>array</em> by this traits </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01297">1297</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a40ec00afcef093183740c958eed9961a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ec00afcef093183740c958eed9961a">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeAddedOrSubtracted.html">Details::op::CanBeAddedOrSubtracted</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Sub &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">TExpr1 const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExpr2 const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction involving a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code>. This operation is generic and takes:</p><ul>
<li>two arrays,</li>
<li>or one array and one number (on either side) <dl class="section return"><dt>Returns</dt><dd>an expression template proxy object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>As no allocation will be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>mpl::IsArray&lt;&gt;</code> to know the exact array types recognized as <em>array</em> by this traits </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01314">1314</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a72286aa84b3cfffd347fe5c5266c2a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72286aa84b3cfffd347fe5c5266c2a05">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TExpr1 , typename TExpr2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structDetails_1_1op_1_1CanBeDivided.html">Details::op::CanBeDivided</a>&lt; TExpr1, TExpr2 &gt;::Value, <a class="el" href="structitk_1_1VariableLengthVectorExpression.html">VariableLengthVectorExpression</a>&lt; TExpr1, TExpr2, Details::op::Div &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">TExpr1 const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TExpr2 const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> by a scalar. This operation is generic and takes one array and one number. </p><dl class="section return"><dt>Returns</dt><dd>an expression template proxy object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>As no allocation will be performed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><code>mpl::IsArray&lt;&gt;</code> to know the exact array types recognized as <em>array</em> by this traits </dd></dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01345">1345</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="ad38e295bac6f8e926d13ab8bd5ec4b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38e295bac6f8e926d13ab8bd5ec4b3f">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>arr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serialization of <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> </p>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01410">1410</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

<p class="reference">References <a class="el" href="itkVariableLengthVector_8h_source.html#l00590">Size()</a>.</p>

</div>
</div>
<a id="a648790605a6460b4fc2c164ecd09e09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648790605a6460b4fc2c164ecd09e09c">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classitk_1_1VariableLengthVector.html">VariableLengthVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code><a class="el" href="classitk_1_1VariableLengthVector.html#a648790605a6460b4fc2c164ecd09e09c">swap()</a></code> overload for <code><a class="el" href="classitk_1_1VariableLengthVector.html" title="Represents an array whose length can be defined at run-time.">VariableLengthVector</a></code> </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01452">1452</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aca3d2a5d6636b217aa753cf7cdd9c29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3d2a5d6636b217aa753cf7cdd9c29a">&#9670;&nbsp;</a></span>m_Data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TValue* itk::VariableLengthVector::m_Data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01009">1009</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a27d4bec3e14933f156745569c63af498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d4bec3e14933f156745569c63af498">&#9670;&nbsp;</a></span>m_LetArrayManageMemory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool itk::VariableLengthVector::m_LetArrayManageMemory { true }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01007">1007</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<a id="a4a2cbe68db8cc4fa5ec1ef3ec1fb2f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2cbe68db8cc4fa5ec1ef3ec1fb2f7f">&#9670;&nbsp;</a></span>m_NumElements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1VariableLengthVector.html#a3405e9cd0ebe9c0dd741d5f5911a7b8c">ElementIdentifier</a> itk::VariableLengthVector::m_NumElements { 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkVariableLengthVector_8h_source.html#l01010">1010</a> of file <a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="itkConstantBoundaryCondition_8h_source.html">itkConstantBoundaryCondition.h</a></li>
<li><a class="el" href="itkVariableLengthVector_8h_source.html">itkVariableLengthVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<hr class="footer"/>
<div class="footer" align="left">
  <small>Tarballs of the nightly generated Doxygen documentation are available
    for the
    <a href="http://public.kitware.com/pub/itk/NightlyDoxygen/InsightDoxygenDocHtml.tar.gz">html</a>,
    <a href="http://public.kitware.com/pub/itk/NightlyDoxygen/InsightDoxygenDocXml.tar.gz">xml</a>, and
    <a href="http://public.kitware.com/pub/itk/NightlyDoxygen/InsightDoxygenDocTag.gz">tag file</a>.
  </small>
</div>
<address class="footer"><small>
Generated on <span id="datetime">unknown</span> for ITK by &#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
