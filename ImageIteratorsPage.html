<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ITK: Image Iterators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<script type="text/javascript" src="build_text.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ITKDoxygenStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="itkLogoSmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ITK
   &#160;<span id="projectnumber">5.3.0</span>
   </div>
   <div id="projectbrief">Insight Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--  Scripts intended to allow users to submit patches with documentation fixes -->
<!-- <script src="https://www.itk.org/Doxygen/js/jquery-1.4.3.min.js" type="text/javascript" charset="utf-8"></script> -->
<!-- <script src="https://www.itk.org/Doxygen/js/editdoxygen.js" type="text/javascript" charset="utf-8"></script> -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Image Iterators </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ImageIteratorsIntroduction"></a>
Introduction</h1>
<p >ImageIterators are the mechanism used in ITK for walking through the image data.</p>
<p >You probably learned image processing with the classical access to the image data using <b>"for loops"</b> like:</p>
<div class="fragment"><div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> nx  = 200;</div>
<div class="line"><span class="keyword">constexpr</span> <span class="keywordtype">int</span> ny  = 100;</div>
<div class="line"> </div>
<div class="line">ImageType image(nx,ny);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> x=0; x&lt;nx; x++) <span class="comment">// for all Columns</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> y=0; y&lt;ny; y++) <span class="comment">// for all Rows</span></div>
<div class="line">  {</div>
<div class="line">    image(x,y) = 10;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p >When what you <em>really</em> mean is:</p>
<div class="fragment"><div class="line">ForAllThePixels  p   in   image Do   p = 100</div>
</div><!-- fragment --><p >ImageIterators gets you closer to this algorithmic abstraction. They abstract the low-level processing of images from the particular implementation of the image class.</p>
<p >Here is how an image iterator is used in ITK:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="itkAddImageFilter_8h.html#ac831674d6d3f7cd2148ae944cbaa7c9d">ImageType::Pointer</a> im = GetAnImageSomeHow();</div>
<div class="line"> </div>
<div class="line">ImageIterator  it( im, im-&gt;GetRequestedRegion() );</div>
<div class="line"> </div>
<div class="line">it.GoToBegin();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>( !it.IsAtEnd() )</div>
<div class="line">{</div>
<div class="line">  it.Set( 10 );</div>
<div class="line">  ++it;</div>
<div class="line">}</div>
<div class="ttc" id="aitkAddImageFilter_8h_html_ac831674d6d3f7cd2148ae944cbaa7c9d"><div class="ttname"><a href="itkAddImageFilter_8h.html#ac831674d6d3f7cd2148ae944cbaa7c9d">Pointer</a></div><div class="ttdeci">SmartPointer&lt; Self &gt; Pointer</div><div class="ttdef"><b>Definition:</b> <a href="itkAddImageFilter_8h_source.html#l00092">itkAddImageFilter.h:92</a></div></div>
</div><!-- fragment --><p >This code can also be written as:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="itkAddImageFilter_8h.html#ac831674d6d3f7cd2148ae944cbaa7c9d">ImageType::Pointer</a> im = GetAnImageSomeHow();</div>
<div class="line"> </div>
<div class="line">ImageIterator  it( im, im-&gt;GetRequestedRegion() );</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (it = it.Begin(); !it.IsAtEnd(); ++it)</div>
<div class="line">{</div>
<div class="line">  it.Set( 10 );</div>
<div class="line">}</div>
</div><!-- fragment --><p >One important advantage of ImageIterators is that they provide support for the N-Dimensional images in ITK. Otherwise it would be impossible (or at least very hard) to write algorithms that work independent of the image dimension.</p>
<p >Another advantage of ImageIterators is that they support walking a region of an image. In fact, one argument of an ImageIterator's constructor defines the region or portion of an image to traverse.</p>
<p >Iterators know a lot about the internal composition of the image, relieving the user from these details. Your algorithm can go through all the pixels of an image without ever knowing the dimension of the image.</p>
<h1><a class="anchor" id="IteratorTypes"></a>
Types of Iterators</h1>
<p >The order in which the image pixels are visited can be quite important for some image processing algorithms and may be inconsequential to other algorithms as long as pixels are accessed as fast as possible.</p>
<p >To address these diverse requirements, ITK implements a set of ImageIterators, always following the "C" philosophy of :</p>
<p >"You only pay for what you use"</p>
<p >Here is a list of some of the different ImageIterators implemented in ITK:</p>
<ul>
<li><a class="el" href="classitk_1_1ImageRegionIterator.html" title="A multi-dimensional iterator templated over image type that walks a region of pixels.">itk::ImageRegionIterator</a></li>
<li><a class="el" href="classitk_1_1ImageRegionReverseIterator.html" title="A multi-dimensional image iterator which only walks a region.">itk::ImageRegionReverseIterator</a></li>
</ul>
<p >Region iterators don't define any specific order to walk over the pixels on the image. The user can be sure though, that all the pixels inside the region will be visited.</p>
<p >The following iterators allow to walk the image in specific directions</p>
<ul>
<li><a class="el" href="classitk_1_1ImageLinearIteratorWithIndex.html" title="A multi-dimensional image iterator that visits image pixels within a region in a &quot;scan-line&quot; order.">itk::ImageLinearIteratorWithIndex</a> Along lines</li>
<li><a class="el" href="classitk_1_1ImageSliceIteratorWithIndex.html" title="A multi-dimensional image iterator that extends the ImageLinearIteratorWithIndex from iteration along...">itk::ImageSliceIteratorWithIndex</a> Along lines, then along planes</li>
</ul>
<p >Iterators in general can have <b>Read/Write</b> access to image pixels. A family of iterators provides <b>Read Only</b> access, in order to preserve the image content. These iterators are equivalent to "C" const pointers :</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> * PixelType iterator;</div>
</div><!-- fragment --><p >or to STL const_iterators:</p>
<div class="fragment"><div class="line">vector&lt;PixelType&gt;::const_iterator  it;</div>
</div><!-- fragment --><p >The class name of the iterator makes clears if it provides const access or not. Some of the <code>const</code> iterators available are</p>
<ul>
<li><a class="el" href="classitk_1_1ImageConstIterator.html" title="A multi-dimensional image iterator templated over image type.">itk::ImageConstIterator</a></li>
<li><a class="el" href="classitk_1_1ImageConstIteratorWithIndex.html" title="A base class for multi-dimensional iterators templated over image type that are designed to efficient...">itk::ImageConstIteratorWithIndex</a></li>
<li><a class="el" href="classitk_1_1ImageLinearConstIteratorWithIndex.html" title="A multi-dimensional image iterator that visits image pixels within a region in a &quot;scan-line&quot; order.">itk::ImageLinearConstIteratorWithIndex</a></li>
<li><a class="el" href="classitk_1_1ImageRegionConstIteratorWithIndex.html" title="A multi-dimensional iterator templated over image type that walks an image region and is specialized ...">itk::ImageRegionConstIteratorWithIndex</a></li>
<li><a class="el" href="classitk_1_1ImageSliceConstIteratorWithIndex.html" title="Multi-dimensional image iterator which only walks a region.">itk::ImageSliceConstIteratorWithIndex</a></li>
</ul>
<h2><a class="anchor" id="NeighbohoodIteratorType"></a>
Other Types of Iterators</h2>
<p >Another group of iterators support a moving neighborhood. Here the neighborhood can "iterate" over an image and a calculation can iterate over the neighborhood. This allows N-dimensional implementations of convolution and finite differences to be implemented succintly. This class of iterators is described in detail on the page <a class="el" href="NeighborhoodIteratorsPage.html">Neighborhood Iterators</a>.</p>
<h2><a class="anchor" id="STL"></a>
ImageIterators vs. STL Iterators</h2>
<p >Given the breadth and complexity of ImageIterators, they are designed to operate slightly differently than STL iterators. In STL, you ask a container for an iterator that will traverse the container. Furthermore, in STL, you frequently compare an iterator against another iterator. Here is a loop to walk over an STL vector.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (it = vec.begin(); it != vec.end(); ++it)</div>
<div class="line">  {}</div>
</div><!-- fragment --><p >ImageIterators, unfortunately, are more complicated than STL iterators. ImageIterators need to store more state information than STL iterators. As one example, ImageIterators can walk a region of an image and an image can have multiple ImageIterators traversing different regions simultaneously. Thus, each ImageIterator must maintain which region it traverses. This results in a fairly heavyweight iterator, where comparing two ImageIterators and constructing iterators is an expensive operation. To address this issue, ImageIterators have a slightly different API than STL iterators.</p>
<p >First, you do not ask the container (the image) for an iterator. Instead, you construct an iterator and tell it which image to traverse. Here is a snippet of code to construct an iterator that will walk a region of an image:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="itkAddImageFilter_8h.html#ac831674d6d3f7cd2148ae944cbaa7c9d">ImageType::Pointer</a> im = GetAnImageSomeHow();</div>
<div class="line"> </div>
<div class="line">ImageIterator  it( im, im-&gt;GetRequestedRegion() );</div>
</div><!-- fragment --><p >Second, since constructing and comparing ImageIterators is expensive, ImageIterators know the beginning and end of the region. So you ask the iterator rather than the container whether the iterator is at the end of a region.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (it = it.Begin(); !it.IsAtEnd(); ++it)</div>
<div class="line">{</div>
<div class="line">  it.Set( 10 );</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="IteratorsRegions"></a>
Regions</h2>
<p >Iterators are typically defined to walk a region of an image. ImageRegions are defined to be rectangular prisms. (Insight also has a number of iterators that can walk a region defined by a spatial function.) The region for an iterator is defined at constructor time. Regions are not validated, so the programmer is responsible for assigning a region that is within the image. Iterator methods Begin() and End() are defined relative to the region. See below.</p>
<h1><a class="anchor" id="IteratorAPI"></a>
Iterator API</h1>
<h2><a class="anchor" id="IteratorsPositioning"></a>
Position</h2>
<h2><a class="anchor" id="IteratorsIntervals"></a>
Half Open Intervals - Begin/End</h2>
<p >Like most iterator implementations, ImageIterators walk a half-open interval. Begin is defined as the first pixel in the region. End is defined as one pixel past the last pixel in the region (one pixel past in the same row). So Begin points a valid pixel in the region and End points to a pixel that is outside the region.</p>
<h2><a class="anchor" id="IteratorsDereferencing"></a>
Dereferencing</h2>
<p >In order to get access to the image data pointed by the iterator, dereferencing is required. This is equivalent to the classical "C" dereferencing code :</p>
<div class="fragment"><div class="line">PixelType * p;    <span class="comment">// creation of the pointer</span></div>
<div class="line">*p = 100;         <span class="comment">// write access to a data</span></div>
<div class="line">PixelType a = *p; <span class="comment">// read access to data</span></div>
</div><!-- fragment --><p >Iterators dereference data using <code>Set()</code> and <code>Get()</code></p>
<div class="fragment"><div class="line">imageIterator.Set( 100 );</div>
<div class="line">PixelType a = imageIterator.Get();</div>
</div><!-- fragment --><h2><a class="anchor" id="IteratorsOperatorPlusPlus"></a>
operator++</h2>
<p >The ++ operator will move the image iterator to the next pixel, according to the particular order in which this iterator walks the imaage.</p>
<h2><a class="anchor" id="IteratorsOperatorMinusMinus"></a>
operator--</h2>
<p >The &ndash; operator will move the image iterator to the previous pixel, according to the particular order in which this iterator walks the imaage.</p>
<h2><a class="anchor" id="IteratorsIteratorsBegin"></a>
Begin()</h2>
<p >Begin() returns an iterator for the same image and region as the current iterator but positioned at the first pixel in the region. The current iterator is not modified.</p>
<h2><a class="anchor" id="IteratorsIteratorsEnd"></a>
End()</h2>
<p >End() returns an iterator for the same image and region as the current iterator but positioned one pixel past the last pixel in the region. The current iterator is not modified.</p>
<h2><a class="anchor" id="IteratorsIteratorsGotoBegin"></a>
GotoBegin()</h2>
<p >GotoBegin() repositions the iterator to the first pixel in the region.</p>
<h2><a class="anchor" id="IteratorsGotoEnd"></a>
GotoEnd()</h2>
<p >GotoEnd() repositions the iterator to one pixel past (in the same row) the last pixel in the region.</p>
<h2><a class="anchor" id="IteratorsIsAtBegin"></a>
IsAtBegin()</h2>
<p >IsAtBegin() returns true if the iterator is positioned at the first pixel in the region, returns false otherwise. IsAtBegin() is faster than comparing an iterator for equivalence to the iterator returned by Begion().</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (it.IsAtBegin()) {}   <span class="comment">// Fast</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (it == it.Begin()) {} <span class="comment">// Slow</span></div>
</div><!-- fragment --><h2><a class="anchor" id="IteratorsIsAtEnd"></a>
IsAtEnd()</h2>
<p >IsAtEnd() returns true if the iterator is positioned one pixel past the last pixel in the region, returns false otherwise. IsAtEnd() is faster than comparing an iterator for equivalence to the iterator returned by End().</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (it.IsAtEnd()) {}   <span class="comment">// Fast</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (it == it.End()) {} <span class="comment">// Slow</span></div>
</div><!-- fragment --><h1><a class="anchor" id="IteratorFinalComment"></a>
Final Comments</h1>
<p >In general, iterators are not the kind of objects that users of the toolkit would need to use. They are rather designed to be used by code developers that add new components to the toolkit, like writting a new Image filter, for example.</p>
<p >Before starting to write code that use iterators, users should consider to verify if the particular operation they intend to apply to the image is not already defined in the form of an existing image filter. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<hr class="footer"/>
<div class="footer" align="left">
  <small>Tarballs of the nightly generated Doxygen documentation are available
    for the
    <a href="https://itk.org/files/NightlyDoxygen/InsightDoxygenDocHtml.tar.gz">html</a>,
    <a href="https://itk.org/files/NightlyDoxygen/InsightDoxygenDocXml.tar.gz">xml</a>, and
    <a href="https://itk.org/files/NightlyDoxygen/InsightDoxygenDocTag.gz">tag file</a>.
  </small>
</div>
<address class="footer"><small>
Generated on <span id="datetime">unknown</span> for ITK by &#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.3
</small></address>
</body>
</html>
