<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ITK: itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js"></script>
<script type="text/javascript" src="build_text.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ITKDoxygenStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="itkLogoSmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ITK
   &#160;<span id="projectnumber">5.4.0</span>
   </div>
   <div id="projectbrief">Insight Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!--  Scripts intended to allow users to submit patches with documentation fixes -->
<!-- <script src="https://www.itk.org/Doxygen/js/jquery-1.4.3.min.js" type="text/javascript" charset="utf-8"></script> -->
<!-- <script src="https://www.itk.org/Doxygen/js/editdoxygen.js" type="text/javascript" charset="utf-8"></script> -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceitk.html">itk</a></li><li class="navelem"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">ConstNeighborhoodIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classitk_1_1ConstNeighborhoodIterator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__DataAccess.html">Data Access Objects</a> &raquo; <a class="el" href="group__Iterators.html">Iterators</a> &raquo; <a class="el" href="group__ImageIterators.html">Image Iterators</a> &#124; <a class="el" href="group__Group-Core.html">Group Core</a> &raquo; <a class="el" href="group__ITKCommon.html">Module ITKCommon</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TImage, typename TBoundaryCondition = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt;<br />
class itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;</div><p >Const version of <a class="el" href="classitk_1_1NeighborhoodIterator.html" title="Defines iteration of a local N-dimensional neighborhood of pixels across an itk::Image.">NeighborhoodIterator</a>, defining iteration of a local N-dimensional neighborhood of pixels across an <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">itk::Image</a>. </p>
<p ><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html" title="Const version of NeighborhoodIterator, defining iteration of a local N-dimensional neighborhood of pi...">ConstNeighborhoodIterator</a> implements the read-only methods of <a class="el" href="classitk_1_1NeighborhoodIterator.html" title="Defines iteration of a local N-dimensional neighborhood of pixels across an itk::Image.">NeighborhoodIterator</a>. It serves as a base class from which other iterators are derived. See <a class="el" href="classitk_1_1NeighborhoodIterator.html" title="Defines iteration of a local N-dimensional neighborhood of pixels across an itk::Image.">NeighborhoodIterator</a> for more complete information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1Neighborhood.html" title="A light-weight container object for storing an N-dimensional neighborhood of values.">Neighborhood</a> </dd>
<dd>
<a class="el" href="classitk_1_1ImageIterator.html" title="A multi-dimensional iterator templated over image type.">ImageIterator</a> </dd>
<dd>
<a class="el" href="classitk_1_1NeighborhoodIterator.html" title="Defines iteration of a local N-dimensional neighborhood of pixels across an itk::Image.">NeighborhoodIterator</a> </dd>
<dd>
<a class="el" href="classitk_1_1ShapedImageNeighborhoodRange.html">ShapedImageNeighborhoodRange</a></dd></dl>
<dl class="section user"><dt>ITK Sphinx Examples: </dt><dd><ul>
<li>&lt;a href= </li>
<li>&lt;a href= </li>
</ul>
</dd></dl>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00050">50</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classitk_1_1ConstNeighborhoodIterator__inherit__graph.svg" width="252" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classitk_1_1ConstNeighborhoodIterator__coll__graph.svg" width="1430" height="332"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa62b5196712c5c1a62eb005c83703656"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aa62b5196712c5c1a62eb005c83703656">BoundaryConditionType</a> = TBoundaryCondition</td></tr>
<tr class="separator:aa62b5196712c5c1a62eb005c83703656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebc659f1ff57f197f1a6df1b2d2c32"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ab2ebc659f1ff57f197f1a6df1b2d2c32">ConstIterator</a> = typename <a class="el" href="classitk_1_1NeighborhoodAllocator.html#ae96e73fb0e96157b87c2c100db099f43">AllocatorType::const_iterator</a></td></tr>
<tr class="separator:ab2ebc659f1ff57f197f1a6df1b2d2c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1ff20a546fc75b38dc05bf0ae0221f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a8b1ff20a546fc75b38dc05bf0ae0221f">DimensionValueType</a> = unsigned int</td></tr>
<tr class="separator:a8b1ff20a546fc75b38dc05bf0ae0221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edc456c5c8554019d55d859f9bd6c23"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4edc456c5c8554019d55d859f9bd6c23">ImageBoundaryConditionConstPointerType</a> = const <a class="el" href="classitk_1_1ImageBoundaryCondition.html">ImageBoundaryCondition</a>&lt; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a>, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aef5d45624b8545df201edcb3c1258804">OutputImageType</a> &gt; *</td></tr>
<tr class="separator:a4edc456c5c8554019d55d859f9bd6c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff9fae47c8a3b019f79628bc0d76e38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abff9fae47c8a3b019f79628bc0d76e38">ImageBoundaryConditionPointerType</a> = <a class="el" href="classitk_1_1ImageBoundaryCondition.html">ImageBoundaryCondition</a>&lt; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a>, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aef5d45624b8545df201edcb3c1258804">OutputImageType</a> &gt; *</td></tr>
<tr class="separator:abff9fae47c8a3b019f79628bc0d76e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b92cf50c9da356552edf7c47e219c76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a> = TImage</td></tr>
<tr class="separator:a2b92cf50c9da356552edf7c47e219c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d2b400c2cdb7bbd67bfe99887bf7a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> = <a class="el" href="structitk_1_1Index.html">Index</a>&lt; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Self::Dimension</a> &gt;</td></tr>
<tr class="separator:a51d2b400c2cdb7bbd67bfe99887bf7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7bd5021a91124b6ce3bb4c27ef9397"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a> = typename TImage::InternalPixelType</td></tr>
<tr class="separator:a4b7bd5021a91124b6ce3bb4c27ef9397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aa122e6502b781cb401189d926af25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a05aa122e6502b781cb401189d926af25">Iterator</a> = typename <a class="el" href="classitk_1_1NeighborhoodAllocator.html#a637787c979657319a8c2ec3642adf951">AllocatorType::iterator</a></td></tr>
<tr class="separator:a05aa122e6502b781cb401189d926af25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a09cee970bf36e099a5f88120e7a3b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2a09cee970bf36e099a5f88120e7a3b1">NeighborhoodAccessorFunctorType</a> = typename ImageType::NeighborhoodAccessorFunctorType</td></tr>
<tr class="separator:a2a09cee970bf36e099a5f88120e7a3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3150f7666a6a1ec3b66ae24bbae4551f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a3150f7666a6a1ec3b66ae24bbae4551f">NeighborhoodType</a> = <a class="el" href="classitk_1_1Neighborhood.html">Neighborhood</a>&lt; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Self::Dimension</a> &gt;</td></tr>
<tr class="separator:a3150f7666a6a1ec3b66ae24bbae4551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45ee297607154e6d655d31782ac6c5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> = typename <a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborhoodType::NeighborIndexType</a></td></tr>
<tr class="separator:ac45ee297607154e6d655d31782ac6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f52d953024abd4f13df12ba2469a53"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> = <a class="el" href="structitk_1_1Offset.html">Offset</a>&lt; VDimension &gt;</td></tr>
<tr class="separator:ae1f52d953024abd4f13df12ba2469a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d45624b8545df201edcb3c1258804"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aef5d45624b8545df201edcb3c1258804">OutputImageType</a> = typename BoundaryConditionType::OutputImageType</td></tr>
<tr class="separator:aef5d45624b8545df201edcb3c1258804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02704022a70c0247b7afca6f5ca6875"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> = typename TImage::PixelType</td></tr>
<tr class="separator:ae02704022a70c0247b7afca6f5ca6875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059f26640530c8a8e88b2e4f0470947d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a059f26640530c8a8e88b2e4f0470947d">RadiusType</a> = <a class="el" href="structitk_1_1Size.html">itk::Size</a>&lt; VDimension &gt;</td></tr>
<tr class="separator:a059f26640530c8a8e88b2e4f0470947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2875878ee83ba56d0e5cba6aa1b70fa0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> = typename TImage::RegionType</td></tr>
<tr class="separator:a2875878ee83ba56d0e5cba6aa1b70fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b35321b744ef5e6185ae4b2cb471a6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> = <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">ConstNeighborhoodIterator</a></td></tr>
<tr class="separator:a03b35321b744ef5e6185ae4b2cb471a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ab1821da50ea8ac7bfce17a376a604"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> = <a class="el" href="structitk_1_1Size.html">itk::Size</a>&lt; VDimension &gt;</td></tr>
<tr class="separator:a64ab1821da50ea8ac7bfce17a376a604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e27ee4b4b5499d441ee09bd12690a7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a58e27ee4b4b5499d441ee09bd12690a7">Superclass</a> = <a class="el" href="classitk_1_1Neighborhood.html">Neighborhood</a>&lt; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a> *, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Self::Dimension</a> &gt;</td></tr>
<tr class="separator:a58e27ee4b4b5499d441ee09bd12690a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classitk_1_1Neighborhood"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classitk_1_1Neighborhood')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood&lt; TImage::InternalPixelType *, TImage::ImageDimension &gt;</a></td></tr>
<tr class="memitem:a6537170c6a9a71bf3c35aa22a463b162 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a6537170c6a9a71bf3c35aa22a463b162">AllocatorType</a> = <a class="el" href="classitk_1_1NeighborhoodAllocator.html">NeighborhoodAllocator</a>&lt; TImage::InternalPixelType * &gt;</td></tr>
<tr class="separator:a6537170c6a9a71bf3c35aa22a463b162 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebc659f1ff57f197f1a6df1b2d2c32 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#ab2ebc659f1ff57f197f1a6df1b2d2c32">ConstIterator</a> = typename <a class="el" href="classitk_1_1NeighborhoodAllocator.html#ae96e73fb0e96157b87c2c100db099f43">AllocatorType::const_iterator</a></td></tr>
<tr class="separator:ab2ebc659f1ff57f197f1a6df1b2d2c32 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf09b9afa5246b3b32f646c318ccc62 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a8cf09b9afa5246b3b32f646c318ccc62">DimensionValueType</a> = unsigned int</td></tr>
<tr class="separator:a8cf09b9afa5246b3b32f646c318ccc62 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aa122e6502b781cb401189d926af25 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a05aa122e6502b781cb401189d926af25">Iterator</a> = typename <a class="el" href="classitk_1_1NeighborhoodAllocator.html#a637787c979657319a8c2ec3642adf951">AllocatorType::iterator</a></td></tr>
<tr class="separator:a05aa122e6502b781cb401189d926af25 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad94b38bb2da9164889440f616f873fa inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a> = <a class="el" href="classitk_1_1Neighborhood.html#adb304a69d576bc7d972c033eeda72374">SizeValueType</a></td></tr>
<tr class="separator:aad94b38bb2da9164889440f616f873fa inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f52d953024abd4f13df12ba2469a53 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> = <a class="el" href="structitk_1_1Offset.html">Offset</a>&lt; VDimension &gt;</td></tr>
<tr class="separator:ae1f52d953024abd4f13df12ba2469a53 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521c2c5214c4cf880dc18f68f7815da4 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a521c2c5214c4cf880dc18f68f7815da4">PixelType</a> = TImage::InternalPixelType *</td></tr>
<tr class="separator:a521c2c5214c4cf880dc18f68f7815da4 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059f26640530c8a8e88b2e4f0470947d inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a059f26640530c8a8e88b2e4f0470947d">RadiusType</a> = <a class="el" href="structitk_1_1Size.html">itk::Size</a>&lt; VDimension &gt;</td></tr>
<tr class="separator:a059f26640530c8a8e88b2e4f0470947d inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ba6776396ed49d1afa42813ecd5592 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> = <a class="el" href="classitk_1_1Neighborhood.html">Neighborhood</a></td></tr>
<tr class="separator:af7ba6776396ed49d1afa42813ecd5592 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ab1821da50ea8ac7bfce17a376a604 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> = <a class="el" href="structitk_1_1Size.html">itk::Size</a>&lt; VDimension &gt;</td></tr>
<tr class="separator:a64ab1821da50ea8ac7bfce17a376a604 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb304a69d576bc7d972c033eeda72374 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#adb304a69d576bc7d972c033eeda72374">SizeValueType</a> = typename <a class="el" href="structitk_1_1Size.html#a45c8a92f64c247709424fb4f6614a05e">SizeType::SizeValueType</a></td></tr>
<tr class="separator:adb304a69d576bc7d972c033eeda72374 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87322d025720e2210fd0b75cc86d21f2 inherit pub_types_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a87322d025720e2210fd0b75cc86d21f2">SliceIteratorType</a> = <a class="el" href="classitk_1_1SliceIterator.html">SliceIterator</a>&lt; TImage::InternalPixelType *, <a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &gt;</td></tr>
<tr class="separator:a87322d025720e2210fd0b75cc86d21f2 inherit pub_types_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5b642ad1078effee372f48b4a2e34faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a5b642ad1078effee372f48b4a2e34faf">ComputeInternalIndex</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> n) const</td></tr>
<tr class="separator:a5b642ad1078effee372f48b4a2e34faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4ea92455fc631ba1c94be86d065310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#afb4ea92455fc631ba1c94be86d065310">ConstNeighborhoodIterator</a> ()=default</td></tr>
<tr class="separator:afb4ea92455fc631ba1c94be86d065310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816ba95eadbd490465b0c2a0fda34040"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a816ba95eadbd490465b0c2a0fda34040">ConstNeighborhoodIterator</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">ConstNeighborhoodIterator</a> &amp;)</td></tr>
<tr class="separator:a816ba95eadbd490465b0c2a0fda34040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f08d47b70b3d6da16cecaef7ed50ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a74f08d47b70b3d6da16cecaef7ed50ea">GetBeginIndex</a> () const</td></tr>
<tr class="separator:a74f08d47b70b3d6da16cecaef7ed50ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6f74ada9e22bdc28bf81c12e9f5c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a6a6f74ada9e22bdc28bf81c12e9f5c7a">GetBound</a> () const</td></tr>
<tr class="separator:a6a6f74ada9e22bdc28bf81c12e9f5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108479498783b93d39564c839060815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceitk.html#a7ee788774b6341347f52db40aec44756">IndexValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a0108479498783b93d39564c839060815">GetBound</a> (<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> n) const</td></tr>
<tr class="separator:a0108479498783b93d39564c839060815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfce65a6cc766b37c6cab949d09c4ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abff9fae47c8a3b019f79628bc0d76e38">ImageBoundaryConditionPointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aecfce65a6cc766b37c6cab949d09c4ea">GetBoundaryCondition</a> () const</td></tr>
<tr class="separator:aecfce65a6cc766b37c6cab949d09c4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0577ec46e30022811fc8c75ebaa43b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a6b0577ec46e30022811fc8c75ebaa43b">GetBoundingBoxAsImageRegion</a> () const</td></tr>
<tr class="separator:a6b0577ec46e30022811fc8c75ebaa43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08533fda6a7a5eb7c98e8f76c635e1b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a08533fda6a7a5eb7c98e8f76c635e1b3">GetCenterPixel</a> () const</td></tr>
<tr class="separator:a08533fda6a7a5eb7c98e8f76c635e1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d81af2dd8466e1f00a0730d18f6e85"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a21d81af2dd8466e1f00a0730d18f6e85">GetCenterPointer</a> () const</td></tr>
<tr class="separator:a21d81af2dd8466e1f00a0730d18f6e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b017e5d200ae2cbfe65ef849a3dfa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#af6b017e5d200ae2cbfe65ef849a3dfa3">GetFastIndexPlusOffset</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;o) const</td></tr>
<tr class="separator:af6b017e5d200ae2cbfe65ef849a3dfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eb4a70b8d5f1715f41545df17fa478"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a53eb4a70b8d5f1715f41545df17fa478">GetImagePointer</a> () const</td></tr>
<tr class="separator:a53eb4a70b8d5f1715f41545df17fa478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59314a56aa56fdc6be7072aed927455"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ab59314a56aa56fdc6be7072aed927455">GetIndex</a> () const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ab59314a56aa56fdc6be7072aed927455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2daaa74ca77fe434bca4a80eb22f70a2"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2daaa74ca77fe434bca4a80eb22f70a2">GetIndex</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;o) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a2daaa74ca77fe434bca4a80eb22f70a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ee833f2abd6bff3ad7b9a11056a697"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a65ee833f2abd6bff3ad7b9a11056a697">GetIndex</a> (<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> i) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a65ee833f2abd6bff3ad7b9a11056a697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b83f2414bf8987401d366d50811287"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a48b83f2414bf8987401d366d50811287">GetNeedToUseBoundaryCondition</a> () const</td></tr>
<tr class="separator:a48b83f2414bf8987401d366d50811287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d33c504e76a97966bb5c9cbf9a139f"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a3150f7666a6a1ec3b66ae24bbae4551f">NeighborhoodType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ad3d33c504e76a97966bb5c9cbf9a139f">GetNeighborhood</a> () const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ad3d33c504e76a97966bb5c9cbf9a139f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083d7a9efd4a11ea2c3933fa3eb87a1b"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a083d7a9efd4a11ea2c3933fa3eb87a1b">GetNext</a> (const unsigned int axis) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a083d7a9efd4a11ea2c3933fa3eb87a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4680352c5d137f63ad226e1d8a90e4"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a3d4680352c5d137f63ad226e1d8a90e4">GetNext</a> (const unsigned int axis, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> i) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a3d4680352c5d137f63ad226e1d8a90e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250f487bef74288e1c1ed95f42a6deba"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a250f487bef74288e1c1ed95f42a6deba">GetPixel</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> i) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a250f487bef74288e1c1ed95f42a6deba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d67f16eddbadda5aaa3ee2eeafc52f"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ad6d67f16eddbadda5aaa3ee2eeafc52f">GetPixel</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;o) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ad6d67f16eddbadda5aaa3ee2eeafc52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd243170c1b2ab97ba326d25f9dd910f"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#acd243170c1b2ab97ba326d25f9dd910f">GetPixel</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;o, bool &amp;IsInBounds) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:acd243170c1b2ab97ba326d25f9dd910f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae707c33b061ff3c5b82a10557f7148d2"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae707c33b061ff3c5b82a10557f7148d2">GetPixel</a> (<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> i, bool &amp;IsInBounds) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ae707c33b061ff3c5b82a10557f7148d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4057591fdcf30f26717e42b842b2052d"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4057591fdcf30f26717e42b842b2052d">GetPrevious</a> (const unsigned int axis) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a4057591fdcf30f26717e42b842b2052d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad833f910be70b2d254fe6fef35319b9c"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ad833f910be70b2d254fe6fef35319b9c">GetPrevious</a> (const unsigned int axis, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> i) const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ad833f910be70b2d254fe6fef35319b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d696adcc0d5dcffd0efa6be2b8397c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2d696adcc0d5dcffd0efa6be2b8397c5">GetRegion</a> () const</td></tr>
<tr class="separator:a2d696adcc0d5dcffd0efa6be2b8397c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdec9182bd4f073aa21625869056b4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aabdec9182bd4f073aa21625869056b4f">GetWrapOffset</a> () const</td></tr>
<tr class="separator:aabdec9182bd4f073aa21625869056b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d07c2a74f2001502f256027f646faee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceitk.html#ad1bf81d1e7a8716a988450b4742282a0">OffsetValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a8d07c2a74f2001502f256027f646faee">GetWrapOffset</a> (<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> n) const</td></tr>
<tr class="separator:a8d07c2a74f2001502f256027f646faee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3548d768aca9c6dbd186badb2d55f1"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#adb3548d768aca9c6dbd186badb2d55f1">GoToBegin</a> () ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:adb3548d768aca9c6dbd186badb2d55f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7d4289798ec335d432ee9139aba77b"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aaa7d4289798ec335d432ee9139aba77b">GoToEnd</a> () ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:aaa7d4289798ec335d432ee9139aba77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1b648a902d5c23e936e5c5c812e48a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a1e1b648a902d5c23e936e5c5c812e48a">InBounds</a> () const</td></tr>
<tr class="separator:a1e1b648a902d5c23e936e5c5c812e48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314a9078cfb562f90bc610973bf002f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a3314a9078cfb562f90bc610973bf002f">IndexInBounds</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> n) const</td></tr>
<tr class="separator:a3314a9078cfb562f90bc610973bf002f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8467f79ebb2808f9dd29d39ab1e9aef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ad8467f79ebb2808f9dd29d39ab1e9aef">IndexInBounds</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a> n, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;internalIndex, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;offset) const</td></tr>
<tr class="separator:ad8467f79ebb2808f9dd29d39ab1e9aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6260e56cd426ea443c0b8c3ff5c78e1f"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a6260e56cd426ea443c0b8c3ff5c78e1f">Initialize</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> &amp;radius, const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a> *ptr, const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> &amp;region) ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a6260e56cd426ea443c0b8c3ff5c78e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4443a24d63b6ee9404849931493b68"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aaf4443a24d63b6ee9404849931493b68">IsAtBegin</a> () const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:aaf4443a24d63b6ee9404849931493b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a21818bcfa7d653296507af32524574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4a21818bcfa7d653296507af32524574">ITK_UNEQUAL_OPERATOR_MEMBER_FUNCTION</a> (<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a>)</td></tr>
<tr class="separator:a4a21818bcfa7d653296507af32524574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438cb0146b802b04a771a2461952cff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a438cb0146b802b04a771a2461952cff8">NeedToUseBoundaryConditionOff</a> ()</td></tr>
<tr class="separator:a438cb0146b802b04a771a2461952cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c912f8cf82aef500b32d677fb1ef369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4c912f8cf82aef500b32d677fb1ef369">NeedToUseBoundaryConditionOn</a> ()</td></tr>
<tr class="separator:a4c912f8cf82aef500b32d677fb1ef369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd3d8dc38cf4ab1fb585ff55556c7d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a9dd3d8dc38cf4ab1fb585ff55556c7d7">operator++</a> ()</td></tr>
<tr class="separator:a9dd3d8dc38cf4ab1fb585ff55556c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ca1ca9cc4dd9edb292c83586959525"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a52ca1ca9cc4dd9edb292c83586959525">operator+=</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;)</td></tr>
<tr class="separator:a52ca1ca9cc4dd9edb292c83586959525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48be6bd8659cbadeb6f0b267fcb6d64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae48be6bd8659cbadeb6f0b267fcb6d64">operator-</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;b) const</td></tr>
<tr class="separator:ae48be6bd8659cbadeb6f0b267fcb6d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454b182923483e09d64b12a9d3c0902b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a454b182923483e09d64b12a9d3c0902b">operator--</a> ()</td></tr>
<tr class="separator:a454b182923483e09d64b12a9d3c0902b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b08e256257befd09919cbef4406d3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac1b08e256257befd09919cbef4406d3a">operator-=</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;)</td></tr>
<tr class="separator:ac1b08e256257befd09919cbef4406d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b277d8be8807ca8134c6d7ef1ed28e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b277d8be8807ca8134c6d7ef1ed28e4">operator&lt;</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;it) const</td></tr>
<tr class="separator:a2b277d8be8807ca8134c6d7ef1ed28e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e747013fbcf77a55ddb9c202ac137b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4e747013fbcf77a55ddb9c202ac137b7">operator&lt;=</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;it) const</td></tr>
<tr class="separator:a4e747013fbcf77a55ddb9c202ac137b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e26efedbee12c75a1f40892efeb468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a32e26efedbee12c75a1f40892efeb468">operator=</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;orig)</td></tr>
<tr class="separator:a32e26efedbee12c75a1f40892efeb468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fbc6322443e2cc103a3f88c1820e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a53fbc6322443e2cc103a3f88c1820e1e">operator==</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;it) const</td></tr>
<tr class="separator:a53fbc6322443e2cc103a3f88c1820e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfd10cdea6637528c8bd1dd303ed12c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abdfd10cdea6637528c8bd1dd303ed12c">operator&gt;</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;it) const</td></tr>
<tr class="separator:abdfd10cdea6637528c8bd1dd303ed12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2481869ec50354f2a494bc59dfe25b4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2481869ec50354f2a494bc59dfe25b4c">operator&gt;=</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;it) const</td></tr>
<tr class="separator:a2481869ec50354f2a494bc59dfe25b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b04c2790d7f9d53b2a101404192c55"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a88b04c2790d7f9d53b2a101404192c55">OverrideBoundaryCondition</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abff9fae47c8a3b019f79628bc0d76e38">ImageBoundaryConditionPointerType</a> i) ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a88b04c2790d7f9d53b2a101404192c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9431da69a342236284e713f5281fbb93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a9431da69a342236284e713f5281fbb93">PrintSelf</a> (std::ostream &amp;, <a class="el" href="classitk_1_1Indent.html">Indent</a>) const override</td></tr>
<tr class="separator:a9431da69a342236284e713f5281fbb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d4cedbd51fd61bbc3936619e521d85"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aa1d4cedbd51fd61bbc3936619e521d85">ResetBoundaryCondition</a> () ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:aa1d4cedbd51fd61bbc3936619e521d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffa7d2436fa01192dba295a31c5d8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4ffa7d2436fa01192dba295a31c5d8de">SetBoundaryCondition</a> (const TBoundaryCondition &amp;c)</td></tr>
<tr class="separator:a4ffa7d2436fa01192dba295a31c5d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad31c4f81a1f71f83ad22c8f2dae27c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4ad31c4f81a1f71f83ad22c8f2dae27c">SetNeedToUseBoundaryCondition</a> (bool b)</td></tr>
<tr class="separator:a4ad31c4f81a1f71f83ad22c8f2dae27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961f8afef66dff0b5f75c5bf9d9ab7b5"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a961f8afef66dff0b5f75c5bf9d9ab7b5">SetRegion</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> &amp;region) ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a961f8afef66dff0b5f75c5bf9d9ab7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b61ee80a925264469fc709abeaad46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a12b61ee80a925264469fc709abeaad46">~ConstNeighborhoodIterator</a> () override=default</td></tr>
<tr class="separator:a12b61ee80a925264469fc709abeaad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:acb864f37a72f08ba4f3fb8bcb86a451f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#acb864f37a72f08ba4f3fb8bcb86a451f">ConstNeighborhoodIterator</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> &amp;radius, const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a> *ptr, const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> &amp;region)</td></tr>
<tr class="separator:acb864f37a72f08ba4f3fb8bcb86a451f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae99ffe953cbc8c7ab88d3994ec0c72bb"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae99ffe953cbc8c7ab88d3994ec0c72bb">IsAtEnd</a> () const ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ae99ffe953cbc8c7ab88d3994ec0c72bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afbfa4277b78bdcbdbb3c14670a3b5244"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#afbfa4277b78bdcbdbb3c14670a3b5244">SetLocation</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;position)</td></tr>
<tr class="separator:afbfa4277b78bdcbdbb3c14670a3b5244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classitk_1_1Neighborhood"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classitk_1_1Neighborhood')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood&lt; TImage::InternalPixelType *, TImage::ImageDimension &gt;</a></td></tr>
<tr class="memitem:a9c8c0462becf628ee90514fdda4bd0da inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a9c8c0462becf628ee90514fdda4bd0da">GetCenterNeighborhoodIndex</a> () const</td></tr>
<tr class="separator:a9c8c0462becf628ee90514fdda4bd0da inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487c6a99dc21028b711ffdaa9a1ca47e inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">TImage::InternalPixelType *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a487c6a99dc21028b711ffdaa9a1ca47e">GetCenterValue</a> () const</td></tr>
<tr class="separator:a487c6a99dc21028b711ffdaa9a1ca47e inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0509ab919d1219e0ef29a3d8b8fd02 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a6c0509ab919d1219e0ef29a3d8b8fd02">GetNameOfClass</a> () const</td></tr>
<tr class="separator:a6c0509ab919d1219e0ef29a3d8b8fd02 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824e68bbe5d0c474767effb32ad1c150 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a824e68bbe5d0c474767effb32ad1c150">GetNeighborhoodIndex</a> (const <a class="el" href="classitk_1_1Neighborhood.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;) const</td></tr>
<tr class="separator:a824e68bbe5d0c474767effb32ad1c150 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fddc4599e03407ff514bac2ac0a102 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a51fddc4599e03407ff514bac2ac0a102">GetOffset</a> (<a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a> i) const</td></tr>
<tr class="separator:a51fddc4599e03407ff514bac2ac0a102 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96f68aaf938ad6308613bce3ae5ba9a inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classitk_1_1Neighborhood.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#ab96f68aaf938ad6308613bce3ae5ba9a">GetRadius</a> () const</td></tr>
<tr class="separator:ab96f68aaf938ad6308613bce3ae5ba9a inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc8c77348504e30658ef0e089334ce6 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#adb304a69d576bc7d972c033eeda72374">SizeValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a8fc8c77348504e30658ef0e089334ce6">GetRadius</a> (<a class="el" href="classitk_1_1Neighborhood.html#a8cf09b9afa5246b3b32f646c318ccc62">DimensionValueType</a> n) const</td></tr>
<tr class="separator:a8fc8c77348504e30658ef0e089334ce6 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0225be6806174c2d4d04e93fa091e6ca inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a0225be6806174c2d4d04e93fa091e6ca">GetSize</a> () const</td></tr>
<tr class="separator:a0225be6806174c2d4d04e93fa091e6ca inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b38d600b5111a098c2190c394511ba0 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#adb304a69d576bc7d972c033eeda72374">SizeValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a7b38d600b5111a098c2190c394511ba0">GetSize</a> (<a class="el" href="classitk_1_1Neighborhood.html#a8cf09b9afa5246b3b32f646c318ccc62">DimensionValueType</a> n) const</td></tr>
<tr class="separator:a7b38d600b5111a098c2190c394511ba0 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc78a892f1b83c72586a97e064c51056 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">std::slice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#afc78a892f1b83c72586a97e064c51056">GetSlice</a> (unsigned int) const</td></tr>
<tr class="separator:afc78a892f1b83c72586a97e064c51056 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdfa278bb6d0f5e0351c8e66d163d02 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceitk.html#ad1bf81d1e7a8716a988450b4742282a0">OffsetValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#accdfa278bb6d0f5e0351c8e66d163d02">GetStride</a> (<a class="el" href="classitk_1_1Neighborhood.html#a8cf09b9afa5246b3b32f646c318ccc62">DimensionValueType</a> axis) const</td></tr>
<tr class="separator:accdfa278bb6d0f5e0351c8e66d163d02 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96a514f76f08fbc7581dfc767bca030 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#aa96a514f76f08fbc7581dfc767bca030">ITK_UNEQUAL_OPERATOR_MEMBER_FUNCTION</a> (<a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a>)</td></tr>
<tr class="separator:aa96a514f76f08fbc7581dfc767bca030 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ccd3e52482b3289dc2d0fc6ade132a inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a28ccd3e52482b3289dc2d0fc6ade132a">Neighborhood</a> ()=default</td></tr>
<tr class="separator:a28ccd3e52482b3289dc2d0fc6ade132a inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f2cae2fb349d5db3aed7397ca34cc1 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a30f2cae2fb349d5db3aed7397ca34cc1">Neighborhood</a> (const <a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &amp;)=default</td></tr>
<tr class="separator:a30f2cae2fb349d5db3aed7397ca34cc1 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b83e249b7b344722ca234c572569e7d inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a1b83e249b7b344722ca234c572569e7d">Neighborhood</a> (<a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a1b83e249b7b344722ca234c572569e7d inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b8996ffbb2e3ad3fafe0428271284a inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#ad4b8996ffbb2e3ad3fafe0428271284a">operator=</a> (const <a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &amp;)=default</td></tr>
<tr class="separator:ad4b8996ffbb2e3ad3fafe0428271284a inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaf9b6cf94baf1172a0be03bdc57869 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a6eaf9b6cf94baf1172a0be03bdc57869">operator=</a> (<a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a6eaf9b6cf94baf1172a0be03bdc57869 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1952db0854e798a02b01953a3abfdb0 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#ad1952db0854e798a02b01953a3abfdb0">operator==</a> (const <a class="el" href="classitk_1_1Neighborhood.html#af7ba6776396ed49d1afa42813ecd5592">Self</a> &amp;other) const</td></tr>
<tr class="separator:ad1952db0854e798a02b01953a3abfdb0 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bd06881e7ccd2a41d6a07fd5fd6f8c inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a78bd06881e7ccd2a41d6a07fd5fd6f8c">Print</a> (std::ostream &amp;os) const</td></tr>
<tr class="separator:a78bd06881e7ccd2a41d6a07fd5fd6f8c inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaca932400993b5d5faf6448dfd856bf inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#aaaca932400993b5d5faf6448dfd856bf">SetRadius</a> (const <a class="el" href="classitk_1_1Neighborhood.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> &amp;)</td></tr>
<tr class="separator:aaaca932400993b5d5faf6448dfd856bf inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b01bc4289848b2ef06f7f56e0ddc1de inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a1b01bc4289848b2ef06f7f56e0ddc1de">SetRadius</a> (const <a class="el" href="classitk_1_1Neighborhood.html#adb304a69d576bc7d972c033eeda72374">SizeValueType</a>)</td></tr>
<tr class="separator:a1b01bc4289848b2ef06f7f56e0ddc1de inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7db0323fe56ed9f6c918cc2cba2b6e inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#abe7db0323fe56ed9f6c918cc2cba2b6e">Size</a> () const</td></tr>
<tr class="separator:abe7db0323fe56ed9f6c918cc2cba2b6e inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2066c3d405017d57ccbae525e209c174 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a2066c3d405017d57ccbae525e209c174">~Neighborhood</a> ()=default</td></tr>
<tr class="separator:a2066c3d405017d57ccbae525e209c174 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56965dceb4c4f0b7fbc711852a6d94de inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#a05aa122e6502b781cb401189d926af25">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a56965dceb4c4f0b7fbc711852a6d94de">End</a> ()</td></tr>
<tr class="separator:a56965dceb4c4f0b7fbc711852a6d94de inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac436f352f72a45983386e0e88f42496a inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#ab2ebc659f1ff57f197f1a6df1b2d2c32">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#ac436f352f72a45983386e0e88f42496a">End</a> () const</td></tr>
<tr class="separator:ac436f352f72a45983386e0e88f42496a inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca476f769d8de82470b90cbeed5e43cf inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#a05aa122e6502b781cb401189d926af25">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#aca476f769d8de82470b90cbeed5e43cf">Begin</a> ()</td></tr>
<tr class="separator:aca476f769d8de82470b90cbeed5e43cf inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e15431e4a473c63b80cf8d8a6a06612 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#ab2ebc659f1ff57f197f1a6df1b2d2c32">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a0e15431e4a473c63b80cf8d8a6a06612">Begin</a> () const</td></tr>
<tr class="separator:a0e15431e4a473c63b80cf8d8a6a06612 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6797b56214e312dd0c276f5845c5a5 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">TImage::InternalPixelType * &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#abc6797b56214e312dd0c276f5845c5a5">operator[]</a> (<a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a> i)</td></tr>
<tr class="separator:abc6797b56214e312dd0c276f5845c5a5 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958a16f7134ab1fa8b824de8affdc109 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">const TImage::InternalPixelType * &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a958a16f7134ab1fa8b824de8affdc109">operator[]</a> (<a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a> i) const</td></tr>
<tr class="separator:a958a16f7134ab1fa8b824de8affdc109 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b149763251c151b0ea1fc0920ee794e inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">TImage::InternalPixelType * &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a4b149763251c151b0ea1fc0920ee794e">GetElement</a> (<a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a> i)</td></tr>
<tr class="separator:a4b149763251c151b0ea1fc0920ee794e inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc9690db0ca30bc95c5b84b0023121e inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">TImage::InternalPixelType * &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a2dc9690db0ca30bc95c5b84b0023121e">operator[]</a> (const <a class="el" href="classitk_1_1Neighborhood.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;o)</td></tr>
<tr class="separator:a2dc9690db0ca30bc95c5b84b0023121e inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369311593e25c34c5b995819c65c08a5 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">const TImage::InternalPixelType * &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a369311593e25c34c5b995819c65c08a5">operator[]</a> (const <a class="el" href="classitk_1_1Neighborhood.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;o) const</td></tr>
<tr class="separator:a369311593e25c34c5b995819c65c08a5 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7daae7bfd0041497485cfda6d8f7582 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#aa7daae7bfd0041497485cfda6d8f7582">SetRadius</a> (const <a class="el" href="classitk_1_1Neighborhood.html#adb304a69d576bc7d972c033eeda72374">SizeValueType</a> *rad)</td></tr>
<tr class="separator:aa7daae7bfd0041497485cfda6d8f7582 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e493ffa3efdda2d52ef96dd32da3c7 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1Neighborhood.html#a6537170c6a9a71bf3c35aa22a463b162">AllocatorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a26e493ffa3efdda2d52ef96dd32da3c7">GetBufferReference</a> ()</td></tr>
<tr class="separator:a26e493ffa3efdda2d52ef96dd32da3c7 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034bd60ef4b1ba41df8157f5f8c76b4 inherit pub_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classitk_1_1Neighborhood.html#a6537170c6a9a71bf3c35aa22a463b162">AllocatorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#aa034bd60ef4b1ba41df8157f5f8c76b4">GetBufferReference</a> () const</td></tr>
<tr class="separator:aa034bd60ef4b1ba41df8157f5f8c76b4 inherit pub_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a79a8b9740e683bf3340878b017af68e0"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a8b1ff20a546fc75b38dc05bf0ae0221f">DimensionValueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Dimension</a> = TImage::ImageDimension</td></tr>
<tr class="separator:a79a8b9740e683bf3340878b017af68e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classitk_1_1Neighborhood"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classitk_1_1Neighborhood')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood&lt; TImage::InternalPixelType *, TImage::ImageDimension &gt;</a></td></tr>
<tr class="memitem:a10fd20cdc4fd2931b696f00f2c28f757 inherit pub_static_attribs_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a10fd20cdc4fd2931b696f00f2c28f757">NeighborhoodDimension</a></td></tr>
<tr class="separator:a10fd20cdc4fd2931b696f00f2c28f757 inherit pub_static_attribs_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab912b0637dd03a85c0005a410889b0dc"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ab912b0637dd03a85c0005a410889b0dc">SetBeginIndex</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;start) ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ab912b0637dd03a85c0005a410889b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d42a158ea8cf99e203ad58bed15cd7b"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a1d42a158ea8cf99e203ad58bed15cd7b">SetBound</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> &amp;) ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a1d42a158ea8cf99e203ad58bed15cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856107011bcd12bc6009bf3a66c9978a"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a856107011bcd12bc6009bf3a66c9978a">SetEndIndex</a> () ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:a856107011bcd12bc6009bf3a66c9978a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61077c9a7624bcb4f6b8d2423d986f5"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ad61077c9a7624bcb4f6b8d2423d986f5">SetLoop</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;p) ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ad61077c9a7624bcb4f6b8d2423d986f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f442e5b922c8fb99b3cd3c601603a3"><td class="memItemLeft" align="right" valign="top">ITK_ITERATOR_VIRTUAL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae2f442e5b922c8fb99b3cd3c601603a3">SetPixelPointers</a> (const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;) ITK_ITERATOR_FINAL</td></tr>
<tr class="separator:ae2f442e5b922c8fb99b3cd3c601603a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classitk_1_1Neighborhood"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classitk_1_1Neighborhood')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood&lt; TImage::InternalPixelType *, TImage::ImageDimension &gt;</a></td></tr>
<tr class="memitem:a1a2efcb44f4cabb2dda62ab06a009d36 inherit pro_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a1a2efcb44f4cabb2dda62ab06a009d36">Allocate</a> (<a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborIndexType</a> i)</td></tr>
<tr class="separator:a1a2efcb44f4cabb2dda62ab06a009d36 inherit pro_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc6e4040ea46bf6ba9636370eeb519a inherit pro_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a4dc6e4040ea46bf6ba9636370eeb519a">ComputeNeighborhoodOffsetTable</a> ()</td></tr>
<tr class="separator:a4dc6e4040ea46bf6ba9636370eeb519a inherit pro_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c4af1285c80f97fd075554e8579bd7 inherit pro_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a71c4af1285c80f97fd075554e8579bd7">ComputeNeighborhoodStrideTable</a> ()</td></tr>
<tr class="separator:a71c4af1285c80f97fd075554e8579bd7 inherit pro_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13403b596b9df856208819eb7517e8d3 inherit pro_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a13403b596b9df856208819eb7517e8d3">PrintSelf</a> (std::ostream &amp;, <a class="el" href="classitk_1_1Indent.html">Indent</a>) const</td></tr>
<tr class="separator:a13403b596b9df856208819eb7517e8d3 inherit pro_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1399473e4315314191cbdd12e0fc7e inherit pro_methods_classitk_1_1Neighborhood"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1Neighborhood.html#a3d1399473e4315314191cbdd12e0fc7e">SetSize</a> ()</td></tr>
<tr class="separator:a3d1399473e4315314191cbdd12e0fc7e inherit pro_methods_classitk_1_1Neighborhood"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad2b561fadd8c9ecf247aef51e38fc05b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ad2b561fadd8c9ecf247aef51e38fc05b">m_Begin</a> { nullptr }</td></tr>
<tr class="separator:ad2b561fadd8c9ecf247aef51e38fc05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa45bb9d78d2b7c5ea9e2498be70e0b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aaa45bb9d78d2b7c5ea9e2498be70e0b9">m_BeginIndex</a> { { 0 } }</td></tr>
<tr class="separator:aaa45bb9d78d2b7c5ea9e2498be70e0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d50d481c1ba292388ea2a3ca22070de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a0d50d481c1ba292388ea2a3ca22070de">m_Bound</a> { { 0 } }</td></tr>
<tr class="separator:a0d50d481c1ba292388ea2a3ca22070de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320897c5aa28b1e90fffda02bb400e69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abff9fae47c8a3b019f79628bc0d76e38">ImageBoundaryConditionPointerType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a320897c5aa28b1e90fffda02bb400e69">m_BoundaryCondition</a> { &amp;<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a244ec69b83c57f2f52e88c0d84a02a90">m_InternalBoundaryCondition</a> }</td></tr>
<tr class="separator:a320897c5aa28b1e90fffda02bb400e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06823fc20a02cb69173229198b49f85"><td class="memItemLeft" align="right" valign="top">ImageType::ConstWeakPointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae06823fc20a02cb69173229198b49f85">m_ConstImage</a> {}</td></tr>
<tr class="separator:ae06823fc20a02cb69173229198b49f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdd020c08e4b7ececb96de3e062a8b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aafdd020c08e4b7ececb96de3e062a8b5">m_End</a> { nullptr }</td></tr>
<tr class="separator:aafdd020c08e4b7ececb96de3e062a8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1772cf4402dbc494df3958d5c43150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a7c1772cf4402dbc494df3958d5c43150">m_EndIndex</a> { { 0 } }</td></tr>
<tr class="separator:a7c1772cf4402dbc494df3958d5c43150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbc266ffec0ce343855ca5935166f40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aebbc266ffec0ce343855ca5935166f40">m_InBounds</a> [<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Dimension</a>] { false }</td></tr>
<tr class="separator:aebbc266ffec0ce343855ca5935166f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ea9b17fd77521beadcbcc16279d64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a45ea9b17fd77521beadcbcc16279d64f">m_InnerBoundsHigh</a> {}</td></tr>
<tr class="separator:a45ea9b17fd77521beadcbcc16279d64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abb0f1b2749f26e15a73ab1f5f43153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a0abb0f1b2749f26e15a73ab1f5f43153">m_InnerBoundsLow</a> {}</td></tr>
<tr class="separator:a0abb0f1b2749f26e15a73ab1f5f43153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244ec69b83c57f2f52e88c0d84a02a90"><td class="memItemLeft" align="right" valign="top">TBoundaryCondition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a244ec69b83c57f2f52e88c0d84a02a90">m_InternalBoundaryCondition</a> {}</td></tr>
<tr class="separator:a244ec69b83c57f2f52e88c0d84a02a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0eb9d630ab726ad903e32a987605e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a9a0eb9d630ab726ad903e32a987605e7">m_IsInBounds</a> { false }</td></tr>
<tr class="separator:a9a0eb9d630ab726ad903e32a987605e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b4e5a01c1755b65566902cfb58fa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ab55b4e5a01c1755b65566902cfb58fa6">m_IsInBoundsValid</a> { false }</td></tr>
<tr class="separator:ab55b4e5a01c1755b65566902cfb58fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dec155c6b65bf6400253c260edf237"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a57dec155c6b65bf6400253c260edf237">m_Loop</a> { { 0 } }</td></tr>
<tr class="separator:a57dec155c6b65bf6400253c260edf237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dcc6ab4186f0233f40474ab2bcdd4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae6dcc6ab4186f0233f40474ab2bcdd4d">m_NeedToUseBoundaryCondition</a> { false }</td></tr>
<tr class="separator:ae6dcc6ab4186f0233f40474ab2bcdd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134ada39d31a2386fb86744bc9377d12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2a09cee970bf36e099a5f88120e7a3b1">NeighborhoodAccessorFunctorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a134ada39d31a2386fb86744bc9377d12">m_NeighborhoodAccessorFunctor</a> {}</td></tr>
<tr class="separator:a134ada39d31a2386fb86744bc9377d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7cc0b678bbb29420ded9730e6b3d612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ab7cc0b678bbb29420ded9730e6b3d612">m_Region</a> {}</td></tr>
<tr class="separator:ab7cc0b678bbb29420ded9730e6b3d612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb8837056d746fa9bce4078edd5ff09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a1bb8837056d746fa9bce4078edd5ff09">m_WrapOffset</a> { { 0 } }</td></tr>
<tr class="separator:a1bb8837056d746fa9bce4078edd5ff09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa62b5196712c5c1a62eb005c83703656" name="aa62b5196712c5c1a62eb005c83703656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62b5196712c5c1a62eb005c83703656">&#9670;&nbsp;</a></span>BoundaryConditionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::BoundaryConditionType =  TBoundaryCondition</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Typedef for boundary condition type. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00083">83</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ab2ebc659f1ff57f197f1a6df1b2d2c32" name="ab2ebc659f1ff57f197f1a6df1b2d2c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ebc659f1ff57f197f1a6df1b2d2c32">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood</a>&lt; TPixel, VDimension, TAllocator &gt;::ConstIterator =  typename <a class="el" href="classitk_1_1NeighborhoodAllocator.html#ae96e73fb0e96157b87c2c100db099f43">AllocatorType::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkNeighborhood_8h_source.html#l00076">76</a> of file <a class="el" href="itkNeighborhood_8h_source.html">itkNeighborhood.h</a>.</p>

</div>
</div>
<a id="a8b1ff20a546fc75b38dc05bf0ae0221f" name="a8b1ff20a546fc75b38dc05bf0ae0221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1ff20a546fc75b38dc05bf0ae0221f">&#9670;&nbsp;</a></span>DimensionValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::DimensionValueType =  unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Type used to refer to space dimensions </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00059">59</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a4edc456c5c8554019d55d859f9bd6c23" name="a4edc456c5c8554019d55d859f9bd6c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edc456c5c8554019d55d859f9bd6c23">&#9670;&nbsp;</a></span>ImageBoundaryConditionConstPointerType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ImageBoundaryConditionConstPointerType =  const <a class="el" href="classitk_1_1ImageBoundaryCondition.html">ImageBoundaryCondition</a>&lt;<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a>, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aef5d45624b8545df201edcb3c1258804">OutputImageType</a>&gt; *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00097">97</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="abff9fae47c8a3b019f79628bc0d76e38" name="abff9fae47c8a3b019f79628bc0d76e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff9fae47c8a3b019f79628bc0d76e38">&#9670;&nbsp;</a></span>ImageBoundaryConditionPointerType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ImageBoundaryConditionPointerType =  <a class="el" href="classitk_1_1ImageBoundaryCondition.html">ImageBoundaryCondition</a>&lt;<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a>, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#aef5d45624b8545df201edcb3c1258804">OutputImageType</a>&gt; *</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Typedef for generic boundary condition pointer </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00096">96</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a2b92cf50c9da356552edf7c47e219c76" name="a2b92cf50c9da356552edf7c47e219c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b92cf50c9da356552edf7c47e219c76">&#9670;&nbsp;</a></span>ImageType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ImageType =  TImage</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Typedef support for common objects </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00076">76</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a51d2b400c2cdb7bbd67bfe99887bf7a9" name="a51d2b400c2cdb7bbd67bfe99887bf7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d2b400c2cdb7bbd67bfe99887bf7a9">&#9670;&nbsp;</a></span>IndexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::IndexType =  <a class="el" href="structitk_1_1Index.html">Index</a>&lt;<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Self::Dimension</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00078">78</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a4b7bd5021a91124b6ce3bb4c27ef9397" name="a4b7bd5021a91124b6ce3bb4c27ef9397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7bd5021a91124b6ce3bb4c27ef9397">&#9670;&nbsp;</a></span>InternalPixelType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::InternalPixelType =  typename TImage::InternalPixelType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract image type information. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00055">55</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a05aa122e6502b781cb401189d926af25" name="a05aa122e6502b781cb401189d926af25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05aa122e6502b781cb401189d926af25">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood</a>&lt; TPixel, VDimension, TAllocator &gt;::Iterator =  typename <a class="el" href="classitk_1_1NeighborhoodAllocator.html#a637787c979657319a8c2ec3642adf951">AllocatorType::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Iterator type alias support Note the naming is intentional, i.e., <a class="el" href="classitk_1_1NeighborhoodAllocator.html#a637787c979657319a8c2ec3642adf951">AllocatorType::iterator</a> and <a class="el" href="classitk_1_1NeighborhoodAllocator.html#ae96e73fb0e96157b87c2c100db099f43">AllocatorType::const_iterator</a>, because the allocator may be a vnl object or other type, which uses this form. </p>

<p class="definition">Definition at line <a class="el" href="itkNeighborhood_8h_source.html#l00075">75</a> of file <a class="el" href="itkNeighborhood_8h_source.html">itkNeighborhood.h</a>.</p>

</div>
</div>
<a id="a2a09cee970bf36e099a5f88120e7a3b1" name="a2a09cee970bf36e099a5f88120e7a3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a09cee970bf36e099a5f88120e7a3b1">&#9670;&nbsp;</a></span>NeighborhoodAccessorFunctorType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::NeighborhoodAccessorFunctorType =  typename ImageType::NeighborhoodAccessorFunctorType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Typedef for the functor used to access neighborhoods of pixel pointers. This is obtained as a trait from the image and is different for <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">Image</a> and <a class="el" href="classitk_1_1VectorImage.html" title="Templated n-dimensional vector image class.">VectorImage</a>. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00093">93</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a3150f7666a6a1ec3b66ae24bbae4551f" name="a3150f7666a6a1ec3b66ae24bbae4551f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3150f7666a6a1ec3b66ae24bbae4551f">&#9670;&nbsp;</a></span>NeighborhoodType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::NeighborhoodType =  <a class="el" href="classitk_1_1Neighborhood.html">Neighborhood</a>&lt;<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a>, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Self::Dimension</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00079">79</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ac45ee297607154e6d655d31782ac6c5b" name="ac45ee297607154e6d655d31782ac6c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45ee297607154e6d655d31782ac6c5b">&#9670;&nbsp;</a></span>NeighborIndexType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::NeighborIndexType =  typename <a class="el" href="classitk_1_1Neighborhood.html#aad94b38bb2da9164889440f616f873fa">NeighborhoodType::NeighborIndexType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Type used to refer to the elements in the list of neighbor pixels. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00088">88</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ae1f52d953024abd4f13df12ba2469a53" name="ae1f52d953024abd4f13df12ba2469a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f52d953024abd4f13df12ba2469a53">&#9670;&nbsp;</a></span>OffsetType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood</a>&lt; TPixel, VDimension, TAllocator &gt;::OffsetType =  <a class="el" href="structitk_1_1Offset.html">Offset</a>&lt;VDimension&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="structitk_1_1Offset.html" title="Represent a n-dimensional offset between two n-dimensional indexes of n-dimensional image.">Offset</a> type used to reference neighbor locations </p>

<p class="definition">Definition at line <a class="el" href="itkNeighborhood_8h_source.html#l00086">86</a> of file <a class="el" href="itkNeighborhood_8h_source.html">itkNeighborhood.h</a>.</p>

</div>
</div>
<a id="aef5d45624b8545df201edcb3c1258804" name="aef5d45624b8545df201edcb3c1258804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d45624b8545df201edcb3c1258804">&#9670;&nbsp;</a></span>OutputImageType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::OutputImageType =  typename BoundaryConditionType::OutputImageType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00085">85</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ae02704022a70c0247b7afca6f5ca6875" name="ae02704022a70c0247b7afca6f5ca6875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02704022a70c0247b7afca6f5ca6875">&#9670;&nbsp;</a></span>PixelType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::PixelType =  typename TImage::PixelType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00056">56</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a059f26640530c8a8e88b2e4f0470947d" name="a059f26640530c8a8e88b2e4f0470947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059f26640530c8a8e88b2e4f0470947d">&#9670;&nbsp;</a></span>RadiusType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood</a>&lt; TPixel, VDimension, TAllocator &gt;::RadiusType =  <a class="el" href="structitk_1_1Size.html">itk::Size</a>&lt;VDimension&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Radius type alias support </p>

<p class="definition">Definition at line <a class="el" href="itkNeighborhood_8h_source.html#l00083">83</a> of file <a class="el" href="itkNeighborhood_8h_source.html">itkNeighborhood.h</a>.</p>

</div>
</div>
<a id="a2875878ee83ba56d0e5cba6aa1b70fa0" name="a2875878ee83ba56d0e5cba6aa1b70fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2875878ee83ba56d0e5cba6aa1b70fa0">&#9670;&nbsp;</a></span>RegionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::RegionType =  typename TImage::RegionType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00077">77</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a03b35321b744ef5e6185ae4b2cb471a6" name="a03b35321b744ef5e6185ae4b2cb471a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b35321b744ef5e6185ae4b2cb471a6">&#9670;&nbsp;</a></span>Self</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;<a class="el" href="itkAddImageFilter_8h.html#aec9acb768e36a04c977b735081c5ed2c">::Self</a> =  <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">ConstNeighborhoodIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Standard class type aliases. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00065">65</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a64ab1821da50ea8ac7bfce17a376a604" name="a64ab1821da50ea8ac7bfce17a376a604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ab1821da50ea8ac7bfce17a376a604">&#9670;&nbsp;</a></span>SizeType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1Neighborhood.html">itk::Neighborhood</a>&lt; TPixel, VDimension, TAllocator &gt;::SizeType =  <a class="el" href="structitk_1_1Size.html">itk::Size</a>&lt;VDimension&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="structitk_1_1Size.html" title="Represent a n-dimensional size (bounds) of a n-dimensional image.">Size</a> and value type alias support </p>

<p class="definition">Definition at line <a class="el" href="itkNeighborhood_8h_source.html#l00079">79</a> of file <a class="el" href="itkNeighborhood_8h_source.html">itkNeighborhood.h</a>.</p>

</div>
</div>
<a id="a58e27ee4b4b5499d441ee09bd12690a7" name="a58e27ee4b4b5499d441ee09bd12690a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e27ee4b4b5499d441ee09bd12690a7">&#9670;&nbsp;</a></span>Superclass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;<a class="el" href="itkAddImageFilter_8h.html#a8c77390f5f26f2ec5a75801152e1f673">::Superclass</a> =  <a class="el" href="classitk_1_1Neighborhood.html">Neighborhood</a>&lt;<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a> *, <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Self::Dimension</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00066">66</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afb4ea92455fc631ba1c94be86d065310" name="afb4ea92455fc631ba1c94be86d065310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4ea92455fc631ba1c94be86d065310">&#9670;&nbsp;</a></span>ConstNeighborhoodIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ConstNeighborhoodIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default constructor </p>

</div>
</div>
<a id="a12b61ee80a925264469fc709abeaad46" name="a12b61ee80a925264469fc709abeaad46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b61ee80a925264469fc709abeaad46">&#9670;&nbsp;</a></span>~ConstNeighborhoodIterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::~<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">ConstNeighborhoodIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Virtual destructor </p>

</div>
</div>
<a id="a816ba95eadbd490465b0c2a0fda34040" name="a816ba95eadbd490465b0c2a0fda34040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816ba95eadbd490465b0c2a0fda34040">&#9670;&nbsp;</a></span>ConstNeighborhoodIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ConstNeighborhoodIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy constructor </p>

</div>
</div>
<a id="acb864f37a72f08ba4f3fb8bcb86a451f" name="acb864f37a72f08ba4f3fb8bcb86a451f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb864f37a72f08ba4f3fb8bcb86a451f">&#9670;&nbsp;</a></span>ConstNeighborhoodIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ConstNeighborhoodIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Constructor which establishes the region size, neighborhood, and image over which to walk. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00110">110</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5b642ad1078effee372f48b4a2e34faf" name="a5b642ad1078effee372f48b4a2e34faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b642ad1078effee372f48b4a2e34faf">&#9670;&nbsp;</a></span>ComputeInternalIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ComputeInternalIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Computes the internal, N-d offset of a pixel array position n from (0,0, ..., 0) in the "upper-left" corner of the neighborhood. </p>

</div>
</div>
<a id="a74f08d47b70b3d6da16cecaef7ed50ea" name="a74f08d47b70b3d6da16cecaef7ed50ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f08d47b70b3d6da16cecaef7ed50ea">&#9670;&nbsp;</a></span>GetBeginIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetBeginIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the N-dimensional starting index of the iterator's position on the image. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00300">300</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a6a6f74ada9e22bdc28bf81c12e9f5c7a" name="a6a6f74ada9e22bdc28bf81c12e9f5c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6f74ada9e22bdc28bf81c12e9f5c7a">&#9670;&nbsp;</a></span>GetBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the array of upper loop bounds used during iteration. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00138">138</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a0108479498783b93d39564c839060815" name="a0108479498783b93d39564c839060815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0108479498783b93d39564c839060815">&#9670;&nbsp;</a></span>GetBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceitk.html#a7ee788774b6341347f52db40aec44756">IndexValueType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the loop bound used to define the edge of a single dimension in the <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">itk::Image</a> region. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00146">146</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="aecfce65a6cc766b37c6cab949d09c4ea" name="aecfce65a6cc766b37c6cab949d09c4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfce65a6cc766b37c6cab949d09c4ea">&#9670;&nbsp;</a></span>GetBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abff9fae47c8a3b019f79628bc0d76e38">ImageBoundaryConditionPointerType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetBoundaryCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00514">514</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a6b0577ec46e30022811fc8c75ebaa43b" name="a6b0577ec46e30022811fc8c75ebaa43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0577ec46e30022811fc8c75ebaa43b">&#9670;&nbsp;</a></span>GetBoundingBoxAsImageRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetBoundingBoxAsImageRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a bounding box for the region spanned by this neighborhood represented by an <a class="el" href="classitk_1_1ImageRegion.html" title="An image region represents a structured region of data.">itk::ImageRegion</a> </p>

</div>
</div>
<a id="a08533fda6a7a5eb7c98e8f76c635e1b3" name="a08533fda6a7a5eb7c98e8f76c635e1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08533fda6a7a5eb7c98e8f76c635e1b3">&#9670;&nbsp;</a></span>GetCenterPixel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetCenterPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel referenced at the center of the <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html" title="Const version of NeighborhoodIterator, defining iteration of a local N-dimensional neighborhood of pi...">ConstNeighborhoodIterator</a>. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00161">161</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a21d81af2dd8466e1f00a0730d18f6e85" name="a21d81af2dd8466e1f00a0730d18f6e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d81af2dd8466e1f00a0730d18f6e85">&#9670;&nbsp;</a></span>GetCenterPointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a> * <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetCenterPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pointer to the center pixel of the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00153">153</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00387">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::operator==()</a>, <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00416">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::operator&gt;()</a>, and <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00425">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::operator&gt;=()</a>.</p>

</div>
</div>
<a id="af6b017e5d200ae2cbfe65ef849a3dfa3" name="af6b017e5d200ae2cbfe65ef849a3dfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b017e5d200ae2cbfe65ef849a3dfa3">&#9670;&nbsp;</a></span>GetFastIndexPlusOffset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetFastIndexPlusOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00182">182</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a53eb4a70b8d5f1715f41545df17fa478" name="a53eb4a70b8d5f1715f41545df17fa478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53eb4a70b8d5f1715f41545df17fa478">&#9670;&nbsp;</a></span>GetImagePointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a> * <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetImagePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a smartpointer to the image on which this iterator operates. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00168">168</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ab59314a56aa56fdc6be7072aed927455" name="ab59314a56aa56fdc6be7072aed927455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59314a56aa56fdc6be7072aed927455">&#9670;&nbsp;</a></span>GetIndex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the N-dimensional index of the iterator's position in the image. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00176">176</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a2daaa74ca77fe434bca4a80eb22f70a2" name="a2daaa74ca77fe434bca4a80eb22f70a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2daaa74ca77fe434bca4a80eb22f70a2">&#9670;&nbsp;</a></span>GetIndex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the image index for neighbor pixel at offset o from the center of the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00277">277</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a65ee833f2abd6bff3ad7b9a11056a697" name="a65ee833f2abd6bff3ad7b9a11056a697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ee833f2abd6bff3ad7b9a11056a697">&#9670;&nbsp;</a></span>GetIndex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the image index for neighbor pixel at index i in the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00285">285</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a48b83f2414bf8987401d366d50811287" name="a48b83f2414bf8987401d366d50811287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b83f2414bf8987401d366d50811287">&#9670;&nbsp;</a></span>GetNeedToUseBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetNeedToUseBoundaryCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00539">539</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ad3d33c504e76a97966bb5c9cbf9a139f" name="ad3d33c504e76a97966bb5c9cbf9a139f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d33c504e76a97966bb5c9cbf9a139f">&#9670;&nbsp;</a></span>GetNeighborhood()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a3150f7666a6a1ec3b66ae24bbae4551f">NeighborhoodType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetNeighborhood </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p ><a class="el" href="namespaceitk_1_1Function.html">Function</a> that "dereferences" a <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html" title="Const version of NeighborhoodIterator, defining iteration of a local N-dimensional neighborhood of pi...">ConstNeighborhoodIterator</a>, returning a <a class="el" href="classitk_1_1Neighborhood.html" title="A light-weight container object for storing an N-dimensional neighborhood of values.">Neighborhood</a> of pixel values. </p>

</div>
</div>
<a id="a083d7a9efd4a11ea2c3933fa3eb87a1b" name="a083d7a9efd4a11ea2c3933fa3eb87a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083d7a9efd4a11ea2c3933fa3eb87a1b">&#9670;&nbsp;</a></span>GetNext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetNext </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel value located one pixel distant from the neighborhood center in the specified positive axis direction. No bounds checking is done on the size of the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00251">251</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a3d4680352c5d137f63ad226e1d8a90e4" name="a3d4680352c5d137f63ad226e1d8a90e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4680352c5d137f63ad226e1d8a90e4">&#9670;&nbsp;</a></span>GetNext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetNext </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel value located i pixels distant from the neighborhood center in the positive specified "axis" direction. No bounds checking is done on the size of the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00242">242</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="itkVectorGradientMagnitudeImageFilter_8h_source.html#l00457">itk::VectorGradientMagnitudeImageFilter&lt; TInputImage, TRealType, TOutputImage &gt;::EvaluateAtNeighborhood()</a>, <a class="el" href="itkVectorGradientMagnitudeImageFilter_8h_source.html#l00343">itk::VectorGradientMagnitudeImageFilter&lt; TInputImage, TRealType, TOutputImage &gt;::EvaluateAtNeighborhood3D()</a>, and <a class="el" href="itkVectorGradientMagnitudeImageFilter_8h_source.html#l00323">itk::VectorGradientMagnitudeImageFilter&lt; TInputImage, TRealType, TOutputImage &gt;::NonPCEvaluateAtNeighborhood()</a>.</p>

</div>
</div>
<a id="a250f487bef74288e1c1ed95f42a6deba" name="a250f487bef74288e1c1ed95f42a6deba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250f487bef74288e1c1ed95f42a6deba">&#9670;&nbsp;</a></span>GetPixel() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel value located at a linear array location i. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00194">194</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ad6d67f16eddbadda5aaa3ee2eeafc52f" name="ad6d67f16eddbadda5aaa3ee2eeafc52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d67f16eddbadda5aaa3ee2eeafc52f">&#9670;&nbsp;</a></span>GetPixel() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel value located at the <a class="el" href="structitk_1_1Offset.html" title="Represent a n-dimensional offset between two n-dimensional indexes of n-dimensional image.">itk::Offset</a> o from the center of the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00220">220</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="acd243170c1b2ab97ba326d25f9dd910f" name="acd243170c1b2ab97ba326d25f9dd910f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd243170c1b2ab97ba326d25f9dd910f">&#9670;&nbsp;</a></span>GetPixel() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetPixel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsInBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel value located at the <a class="el" href="structitk_1_1Offset.html" title="Represent a n-dimensional offset between two n-dimensional indexes of n-dimensional image.">itk::Offset</a> o from the center of the neighborhood. Sets "IsInBounds" to true if the offset is inside the image and the pixel value returned is an actual pixel in the image. Sets "IsInBounds" to false if the offset is outside the image and the pixel value returned is a boundary condition. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00233">233</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ae707c33b061ff3c5b82a10557f7148d2" name="ae707c33b061ff3c5b82a10557f7148d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae707c33b061ff3c5b82a10557f7148d2">&#9670;&nbsp;</a></span>GetPixel() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetPixel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>IsInBounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the pixel value located at a linear array location i. Sets "IsInBounds" to true if the location is inside the image and the pixel value returned is an actual pixel in the image. Sets "IsInBounds" to false if the location is outside the image and the pixel value returned is a boundary condition. </p>

</div>
</div>
<a id="a4057591fdcf30f26717e42b842b2052d" name="a4057591fdcf30f26717e42b842b2052d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4057591fdcf30f26717e42b842b2052d">&#9670;&nbsp;</a></span>GetPrevious() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetPrevious </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel value located one pixel distant from the neighborhood center in the specified negative axis direction. No bounds checking is done on the size of the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00269">269</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ad833f910be70b2d254fe6fef35319b9c" name="ad833f910be70b2d254fe6fef35319b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad833f910be70b2d254fe6fef35319b9c">&#9670;&nbsp;</a></span>GetPrevious() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae02704022a70c0247b7afca6f5ca6875">PixelType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetPrevious </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the pixel value located i pixels distant from the neighborhood center in the negative specified "axis" direction. No bounds checking is done on the size of the neighborhood. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00260">260</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="itkVectorGradientMagnitudeImageFilter_8h_source.html#l00457">itk::VectorGradientMagnitudeImageFilter&lt; TInputImage, TRealType, TOutputImage &gt;::EvaluateAtNeighborhood()</a>, <a class="el" href="itkVectorGradientMagnitudeImageFilter_8h_source.html#l00343">itk::VectorGradientMagnitudeImageFilter&lt; TInputImage, TRealType, TOutputImage &gt;::EvaluateAtNeighborhood3D()</a>, and <a class="el" href="itkVectorGradientMagnitudeImageFilter_8h_source.html#l00323">itk::VectorGradientMagnitudeImageFilter&lt; TInputImage, TRealType, TOutputImage &gt;::NonPCEvaluateAtNeighborhood()</a>.</p>

</div>
</div>
<a id="a2d696adcc0d5dcffd0efa6be2b8397c5" name="a2d696adcc0d5dcffd0efa6be2b8397c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d696adcc0d5dcffd0efa6be2b8397c5">&#9670;&nbsp;</a></span>GetRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the region of iteration. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00292">292</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="aabdec9182bd4f073aa21625869056b4f" name="aabdec9182bd4f073aa21625869056b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabdec9182bd4f073aa21625869056b4f">&#9670;&nbsp;</a></span>GetWrapOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetWrapOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the offsets used to wrap across dimensional boundaries. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00312">312</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a8d07c2a74f2001502f256027f646faee" name="a8d07c2a74f2001502f256027f646faee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d07c2a74f2001502f256027f646faee">&#9670;&nbsp;</a></span>GetWrapOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceitk.html#ad1bf81d1e7a8716a988450b4742282a0">OffsetValueType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GetWrapOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the internal offset associated with wrapping around a single dimension's region boundary in the <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">itk::Image</a>. An offset for each dimension is necessary to shift pointers when wrapping around region edges because region memory is not necessarily contiguous within the buffer. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00323">323</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="adb3548d768aca9c6dbd186badb2d55f1" name="adb3548d768aca9c6dbd186badb2d55f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3548d768aca9c6dbd186badb2d55f1">&#9670;&nbsp;</a></span>GoToBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GoToBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method for rewinding the iterator to its beginning pixel. </p>

<p class="reference">Referenced by <a class="el" href="itkImageToNeighborhoodSampleAdaptor_8h_source.html#l00275">itk::Statistics::ImageToNeighborhoodSampleAdaptor&lt; TImage, TBoundaryCondition &gt;::Begin()</a>.</p>

</div>
</div>
<a id="aaa7d4289798ec335d432ee9139aba77b" name="aaa7d4289798ec335d432ee9139aba77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7d4289798ec335d432ee9139aba77b">&#9670;&nbsp;</a></span>GoToEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::GoToEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Method for sending the iterator to one past the last pixel in its region. </p>

<p class="reference">Referenced by <a class="el" href="itkImageToNeighborhoodSampleAdaptor_8h_source.html#l00286">itk::Statistics::ImageToNeighborhoodSampleAdaptor&lt; TImage, TBoundaryCondition &gt;::End()</a>.</p>

</div>
</div>
<a id="a1e1b648a902d5c23e936e5c5c812e48a" name="a1e1b648a902d5c23e936e5c5c812e48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1b648a902d5c23e936e5c5c812e48a">&#9670;&nbsp;</a></span>InBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::InBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns false if the iterator overlaps region boundaries, true otherwise. Also updates an internal boolean array indicating which of the iterator's faces are out of bounds. </p>

</div>
</div>
<a id="a3314a9078cfb562f90bc610973bf002f" name="a3314a9078cfb562f90bc610973bf002f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3314a9078cfb562f90bc610973bf002f">&#9670;&nbsp;</a></span>IndexInBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::IndexInBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if the neighborhood index is within region boundaries, false otherwise. </p>

</div>
</div>
<a id="ad8467f79ebb2808f9dd29d39ab1e9aef" name="ad8467f79ebb2808f9dd29d39ab1e9aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8467f79ebb2808f9dd29d39ab1e9aef">&#9670;&nbsp;</a></span>IndexInBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::IndexInBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ac45ee297607154e6d655d31782ac6c5b">NeighborIndexType</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"><em>internalIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns true if the neighborhood index is within region boundaries, false otherwise. If false, then internalIndex and offset are calculated. Otherwise their values are left unchanged. Also updates an internal boolean array indicating which of the iterator's faces are out of bounds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>- linear neighborhood index. </td></tr>
    <tr><td class="paramname">internalIndex</td><td>- calculated for index <code>n</code> only when the neighborhood is not completely within region boundaries. </td></tr>
    <tr><td class="paramname">offset</td><td>- per-dimension offsets for index n to nearest boundary index, calculate only when the neighborhood is not completely within region boundaries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6260e56cd426ea443c0b8c3ff5c78e1f" name="a6260e56cd426ea443c0b8c3ff5c78e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6260e56cd426ea443c0b8c3ff5c78e1f">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> &amp;&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2b92cf50c9da356552edf7c47e219c76">ImageType</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initializes the iterator to walk a particular image and a particular region of that image. </p>

</div>
</div>
<a id="aaf4443a24d63b6ee9404849931493b68" name="aaf4443a24d63b6ee9404849931493b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4443a24d63b6ee9404849931493b68">&#9670;&nbsp;</a></span>IsAtBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::IsAtBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method for determining whether the iterator is at the beginning of its iteration region. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00345">345</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ae99ffe953cbc8c7ab88d3994ec0c72bb" name="ae99ffe953cbc8c7ab88d3994ec0c72bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99ffe953cbc8c7ab88d3994ec0c72bb">&#9670;&nbsp;</a></span>IsAtEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::IsAtEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method for determining whether the iterator has reached the end of its iteration region. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00353">353</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">References <a class="el" href="itkMath_8h_source.html#l00056">itk::Math::e</a>.</p>

</div>
</div>
<a id="a4a21818bcfa7d653296507af32524574" name="a4a21818bcfa7d653296507af32524574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a21818bcfa7d653296507af32524574">&#9670;&nbsp;</a></span>ITK_UNEQUAL_OPERATOR_MEMBER_FUNCTION()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ITK_UNEQUAL_OPERATOR_MEMBER_FUNCTION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a438cb0146b802b04a771a2461952cff8" name="a438cb0146b802b04a771a2461952cff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438cb0146b802b04a771a2461952cff8">&#9670;&nbsp;</a></span>NeedToUseBoundaryConditionOff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::NeedToUseBoundaryConditionOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00527">527</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a4c912f8cf82aef500b32d677fb1ef369" name="a4c912f8cf82aef500b32d677fb1ef369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c912f8cf82aef500b32d677fb1ef369">&#9670;&nbsp;</a></span>NeedToUseBoundaryConditionOn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::NeedToUseBoundaryConditionOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00521">521</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a9dd3d8dc38cf4ab1fb585ff55556c7d7" name="a9dd3d8dc38cf4ab1fb585ff55556c7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd3d8dc38cf4ab1fb585ff55556c7d7">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Increments the pointers in the <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html" title="Const version of NeighborhoodIterator, defining iteration of a local N-dimensional neighborhood of pi...">ConstNeighborhoodIterator</a>, wraps across boundaries automatically, accounting for the disparity in the buffer size and the region size of the image. </p>

</div>
</div>
<a id="a52ca1ca9cc4dd9edb292c83586959525" name="a52ca1ca9cc4dd9edb292c83586959525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ca1ca9cc4dd9edb292c83586959525">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Addition of an <a class="el" href="structitk_1_1Offset.html" title="Represent a n-dimensional offset between two n-dimensional indexes of n-dimensional image.">itk::Offset</a>. Note that this method does not do any bounds checking. Adding an offset that moves the iterator out of its assigned region will produce undefined results. </p>

</div>
</div>
<a id="ae48be6bd8659cbadeb6f0b267fcb6d64" name="ae48be6bd8659cbadeb6f0b267fcb6d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48be6bd8659cbadeb6f0b267fcb6d64">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Distance between two iterators </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00456">456</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">References <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00605">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::m_Loop</a>.</p>

</div>
</div>
<a id="a454b182923483e09d64b12a9d3c0902b" name="a454b182923483e09d64b12a9d3c0902b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454b182923483e09d64b12a9d3c0902b">&#9670;&nbsp;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Decrements the pointers in the <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html" title="Const version of NeighborhoodIterator, defining iteration of a local N-dimensional neighborhood of pi...">ConstNeighborhoodIterator</a>, wraps across boundaries automatically, accounting for the disparity in the buffer size and the region size of the image. </p>

</div>
</div>
<a id="ac1b08e256257befd09919cbef4406d3a" name="ac1b08e256257befd09919cbef4406d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b08e256257befd09919cbef4406d3a">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Subtraction of an <a class="el" href="structitk_1_1Offset.html" title="Represent a n-dimensional offset between two n-dimensional indexes of n-dimensional image.">itk::Offset</a>. Note that this method does not do any bounds checking. Subtracting an offset that moves the iterator out of its assigned region will produce undefined results. </p>

</div>
</div>
<a id="a2b277d8be8807ca8134c6d7ef1ed28e4" name="a2b277d8be8807ca8134c6d7ef1ed28e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b277d8be8807ca8134c6d7ef1ed28e4">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a boolean &lt; comparison of the memory addresses of the center elements of two ConstNeighborhoodIterators of like pixel type and dimensionality. The radii of the iterators are ignored. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00397">397</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a4e747013fbcf77a55ddb9c202ac137b7" name="a4e747013fbcf77a55ddb9c202ac137b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e747013fbcf77a55ddb9c202ac137b7">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a boolean &lt; comparison of the memory addresses of the center elements of two ConstNeighborhoodIterators of like pixel type and dimensionality. The radii of the iterators are ignored. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00406">406</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a32e26efedbee12c75a1f40892efeb468" name="a32e26efedbee12c75a1f40892efeb468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e26efedbee12c75a1f40892efeb468">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp; <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>orig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Assignment operator </p>

</div>
</div>
<a id="a53fbc6322443e2cc103a3f88c1820e1e" name="a53fbc6322443e2cc103a3f88c1820e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fbc6322443e2cc103a3f88c1820e1e">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a boolean == comparison of the memory addresses of the center elements of two ConstNeighborhoodIterators of like pixel type and dimensionality. The radii of the iterators are ignored. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00387">387</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">References <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00153">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::GetCenterPointer()</a>.</p>

</div>
</div>
<a id="abdfd10cdea6637528c8bd1dd303ed12c" name="abdfd10cdea6637528c8bd1dd303ed12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdfd10cdea6637528c8bd1dd303ed12c">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a boolean &gt; comparison of the memory addresses of the center elements of two ConstNeighborhoodIterators of like pixel type and dimensionality. The radii of the iterators are ignored. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00416">416</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">References <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00153">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::GetCenterPointer()</a>.</p>

</div>
</div>
<a id="a2481869ec50354f2a494bc59dfe25b4c" name="a2481869ec50354f2a494bc59dfe25b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2481869ec50354f2a494bc59dfe25b4c">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a03b35321b744ef5e6185ae4b2cb471a6">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns a boolean &gt;= comparison of the memory addresses of the center elements of two ConstNeighborhoodIterators of like pixel type and dimensionality. The radii of the iterators are ignored. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00425">425</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">References <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00153">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::GetCenterPointer()</a>.</p>

</div>
</div>
<a id="a88b04c2790d7f9d53b2a101404192c55" name="a88b04c2790d7f9d53b2a101404192c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b04c2790d7f9d53b2a101404192c55">&#9670;&nbsp;</a></span>OverrideBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::OverrideBoundaryCondition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abff9fae47c8a3b019f79628bc0d76e38">ImageBoundaryConditionPointerType</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Allows a user to override the internal boundary condition. Care should be taken to ensure that the overriding boundary condition is a persistent object during the time it is referenced. The overriding condition can be of a different type than the default type as long as it is a subclass of <a class="el" href="classitk_1_1ImageBoundaryCondition.html" title="A virtual base object that defines an interface to a class of boundary condition objects for use by n...">ImageBoundaryCondition</a>. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00492">492</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a9431da69a342236284e713f5281fbb93" name="a9431da69a342236284e713f5281fbb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9431da69a342236284e713f5281fbb93">&#9670;&nbsp;</a></span>PrintSelf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::PrintSelf </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classitk_1_1Indent.html">Indent</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Standard itk print method </p>

<p>Reimplemented from <a class="el" href="classitk_1_1Neighborhood.html#a13403b596b9df856208819eb7517e8d3">itk::Neighborhood&lt; TImage::InternalPixelType *, TImage::ImageDimension &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classitk_1_1ConstShapedNeighborhoodIterator.html#a1eff52cee68441475e37585ca25f32ed">itk::ConstShapedNeighborhoodIterator&lt; TImage, ZeroFluxNeumannBoundaryCondition&lt; TImage &gt; &gt;</a>, and <a class="el" href="classitk_1_1ConstShapedNeighborhoodIterator.html#a1eff52cee68441475e37585ca25f32ed">itk::ConstShapedNeighborhoodIterator&lt; ImageType, ZeroFluxNeumannBoundaryCondition&lt; ImageType &gt; &gt;</a>.</p>

</div>
</div>
<a id="aa1d4cedbd51fd61bbc3936619e521d85" name="aa1d4cedbd51fd61bbc3936619e521d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d4cedbd51fd61bbc3936619e521d85">&#9670;&nbsp;</a></span>ResetBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::ResetBoundaryCondition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Resets the boundary condition to the internal, default conditions specified by the template parameter. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00500">500</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ab912b0637dd03a85c0005a410889b0dc" name="ab912b0637dd03a85c0005a410889b0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab912b0637dd03a85c0005a410889b0dc">&#9670;&nbsp;</a></span>SetBeginIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetBeginIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default method for setting the index of the first pixel in the iteration region. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00574">574</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a1d42a158ea8cf99e203ad58bed15cd7b" name="a1d42a158ea8cf99e203ad58bed15cd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d42a158ea8cf99e203ad58bed15cd7b">&#9670;&nbsp;</a></span>SetBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a64ab1821da50ea8ac7bfce17a376a604">SizeType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Method for setting internal loop boundaries. This method must be defined in each subclass because each subclass may handle loop boundaries differently. </p>

</div>
</div>
<a id="a4ffa7d2436fa01192dba295a31c5d8de" name="a4ffa7d2436fa01192dba295a31c5d8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffa7d2436fa01192dba295a31c5d8de">&#9670;&nbsp;</a></span>SetBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetBoundaryCondition </td>
          <td>(</td>
          <td class="paramtype">const TBoundaryCondition &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Sets the internal, default boundary condition. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00507">507</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a856107011bcd12bc6009bf3a66c9978a" name="a856107011bcd12bc6009bf3a66c9978a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856107011bcd12bc6009bf3a66c9978a">&#9670;&nbsp;</a></span>SetEndIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetEndIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default method for setting the index of the first pixel in the iteration region. </p>

</div>
</div>
<a id="afbfa4277b78bdcbdbb3c14670a3b5244" name="afbfa4277b78bdcbdbb3c14670a3b5244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfa4277b78bdcbdbb3c14670a3b5244">&#9670;&nbsp;</a></span>SetLocation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetLocation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This method positions the iterator at an indexed location in the image. SetLocation should <em>NOT</em> be used to update the position of the iterator during iteration, only for initializing it to a position prior to iteration. This method is not optimized for speed. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00435">435</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ad61077c9a7624bcb4f6b8d2423d986f5" name="ad61077c9a7624bcb4f6b8d2423d986f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61077c9a7624bcb4f6b8d2423d986f5">&#9670;&nbsp;</a></span>SetLoop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetLoop </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default method for setting the coordinate location of the iterator. Loop indices correspond to the actual <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">Image</a> region index. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00552">552</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a4ad31c4f81a1f71f83ad22c8f2dae27c" name="a4ad31c4f81a1f71f83ad22c8f2dae27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad31c4f81a1f71f83ad22c8f2dae27c">&#9670;&nbsp;</a></span>SetNeedToUseBoundaryCondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetNeedToUseBoundaryCondition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00533">533</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ae2f442e5b922c8fb99b3cd3c601603a3" name="ae2f442e5b922c8fb99b3cd3c601603a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f442e5b922c8fb99b3cd3c601603a3">&#9670;&nbsp;</a></span>SetPixelPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetPixelPointers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default method for setting the values of the internal pointers to <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">itk::Image</a> memory buffer locations. This method should generally only be called when the iterator is initialized. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#afbfa4277b78bdcbdbb3c14670a3b5244">SetLocation</a> </dd></dl>

</div>
</div>
<a id="a961f8afef66dff0b5f75c5bf9d9ab7b5" name="a961f8afef66dff0b5f75c5bf9d9ab7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a961f8afef66dff0b5f75c5bf9d9ab7b5">&#9670;&nbsp;</a></span>SetRegion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ITK_ITERATOR_VIRTUAL void <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::SetRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the region to iterate over. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a79a8b9740e683bf3340878b017af68e0" name="a79a8b9740e683bf3340878b017af68e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a8b9740e683bf3340878b017af68e0">&#9670;&nbsp;</a></span>Dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a8b1ff20a546fc75b38dc05bf0ae0221f">DimensionValueType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::Dimension = TImage::ImageDimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Save the image dimension. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00062">62</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ad2b561fadd8c9ecf247aef51e38fc05b" name="ad2b561fadd8c9ecf247aef51e38fc05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b561fadd8c9ecf247aef51e38fc05b">&#9670;&nbsp;</a></span>m_Begin</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a>* <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_Begin { nullptr }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A pointer to the first pixel in the iteration region. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00592">592</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="aaa45bb9d78d2b7c5ea9e2498be70e0b9" name="aaa45bb9d78d2b7c5ea9e2498be70e0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa45bb9d78d2b7c5ea9e2498be70e0b9">&#9670;&nbsp;</a></span>m_BeginIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_BeginIndex { { 0 } }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The starting index for iteration within the <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">itk::Image</a> region on which this <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html" title="Const version of NeighborhoodIterator, defining iteration of a local N-dimensional neighborhood of pi...">ConstNeighborhoodIterator</a> is defined. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00586">586</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a0d50d481c1ba292388ea2a3ca22070de" name="a0d50d481c1ba292388ea2a3ca22070de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d50d481c1ba292388ea2a3ca22070de">&#9670;&nbsp;</a></span>m_Bound</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_Bound { { 0 } }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >An array of upper looping boundaries used during iteration. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00589">589</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a320897c5aa28b1e90fffda02bb400e69" name="a320897c5aa28b1e90fffda02bb400e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320897c5aa28b1e90fffda02bb400e69">&#9670;&nbsp;</a></span>m_BoundaryCondition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#abff9fae47c8a3b019f79628bc0d76e38">ImageBoundaryConditionPointerType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_BoundaryCondition { &amp;<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a244ec69b83c57f2f52e88c0d84a02a90">m_InternalBoundaryCondition</a> }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Pointer to the actual boundary condition that will be used. By default this points to m_BoundaryCondition, but OverrideBoundaryCondition allows a user to point this variable an external boundary condition. <br  />
 </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00624">624</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ae06823fc20a02cb69173229198b49f85" name="ae06823fc20a02cb69173229198b49f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06823fc20a02cb69173229198b49f85">&#9670;&nbsp;</a></span>m_ConstImage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ImageType::ConstWeakPointer <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_ConstImage {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The image on which iteration is defined. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00595">595</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="aafdd020c08e4b7ececb96de3e062a8b5" name="aafdd020c08e4b7ececb96de3e062a8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdd020c08e4b7ececb96de3e062a8b5">&#9670;&nbsp;</a></span>m_End</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a4b7bd5021a91124b6ce3bb4c27ef9397">InternalPixelType</a>* <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_End { nullptr }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A pointer to one past the last pixel in the iteration region. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00598">598</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a7c1772cf4402dbc494df3958d5c43150" name="a7c1772cf4402dbc494df3958d5c43150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1772cf4402dbc494df3958d5c43150">&#9670;&nbsp;</a></span>m_EndIndex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_EndIndex { { 0 } }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The end index for iteration within the <a class="el" href="classitk_1_1Image.html" title="Templated n-dimensional image class.">itk::Image</a> region on which this <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html" title="Const version of NeighborhoodIterator, defining iteration of a local N-dimensional neighborhood of pi...">ConstNeighborhoodIterator</a> is defined. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00602">602</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="aebbc266ffec0ce343855ca5935166f40" name="aebbc266ffec0ce343855ca5935166f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbc266ffec0ce343855ca5935166f40">&#9670;&nbsp;</a></span>m_InBounds</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_InBounds[<a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a79a8b9740e683bf3340878b017af68e0">Dimension</a>] { false }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Denotes which of the iterators dimensional sides spill outside region of interest boundaries. By default <code>false</code> for each dimension. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00628">628</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a45ea9b17fd77521beadcbcc16279d64f" name="a45ea9b17fd77521beadcbcc16279d64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ea9b17fd77521beadcbcc16279d64f">&#9670;&nbsp;</a></span>m_InnerBoundsHigh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_InnerBoundsHigh {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Upper threshold of in-bounds loop counter values. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00642">642</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a0abb0f1b2749f26e15a73ab1f5f43153" name="a0abb0f1b2749f26e15a73ab1f5f43153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abb0f1b2749f26e15a73ab1f5f43153">&#9670;&nbsp;</a></span>m_InnerBoundsLow</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_InnerBoundsLow {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Lower threshold of in-bounds loop counter values. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00639">639</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a244ec69b83c57f2f52e88c0d84a02a90" name="a244ec69b83c57f2f52e88c0d84a02a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244ec69b83c57f2f52e88c0d84a02a90">&#9670;&nbsp;</a></span>m_InternalBoundaryCondition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TBoundaryCondition <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_InternalBoundaryCondition {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Default boundary condition. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00618">618</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a9a0eb9d630ab726ad903e32a987605e7" name="a9a0eb9d630ab726ad903e32a987605e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0eb9d630ab726ad903e32a987605e7">&#9670;&nbsp;</a></span>m_IsInBounds</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_IsInBounds { false }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Denotes if iterator is entirely within bounds </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00631">631</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ab55b4e5a01c1755b65566902cfb58fa6" name="ab55b4e5a01c1755b65566902cfb58fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b4e5a01c1755b65566902cfb58fa6">&#9670;&nbsp;</a></span>m_IsInBoundsValid</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_IsInBoundsValid { false }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Is the m_InBounds and m_IsInBounds variables up to date? Set to false whenever the iterator is repositioned. Set to true within <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a1e1b648a902d5c23e936e5c5c812e48a">InBounds()</a>. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00636">636</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a57dec155c6b65bf6400253c260edf237" name="a57dec155c6b65bf6400253c260edf237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dec155c6b65bf6400253c260edf237">&#9670;&nbsp;</a></span>m_Loop</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a51d2b400c2cdb7bbd67bfe99887bf7a9">IndexType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_Loop { { 0 } }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="classitk_1_1Array.html" title="Array class with size defined at construction time.">Array</a> of loop counters used during iteration. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00605">605</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00456">itk::ConstNeighborhoodIterator&lt; TImage, TBoundaryCondition &gt;::operator-()</a>.</p>

</div>
</div>
<a id="ae6dcc6ab4186f0233f40474ab2bcdd4d" name="ae6dcc6ab4186f0233f40474ab2bcdd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6dcc6ab4186f0233f40474ab2bcdd4d">&#9670;&nbsp;</a></span>m_NeedToUseBoundaryCondition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_NeedToUseBoundaryCondition { false }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Does the specified region need to worry about boundary conditions? </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00645">645</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a134ada39d31a2386fb86744bc9377d12" name="a134ada39d31a2386fb86744bc9377d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134ada39d31a2386fb86744bc9377d12">&#9670;&nbsp;</a></span>m_NeighborhoodAccessorFunctor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2a09cee970bf36e099a5f88120e7a3b1">NeighborhoodAccessorFunctorType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_NeighborhoodAccessorFunctor {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p ><a class="el" href="namespaceitk_1_1Functor.html">Functor</a> type used to access neighborhoods of pixel pointers </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00648">648</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="ab7cc0b678bbb29420ded9730e6b3d612" name="ab7cc0b678bbb29420ded9730e6b3d612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7cc0b678bbb29420ded9730e6b3d612">&#9670;&nbsp;</a></span>m_Region</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#a2875878ee83ba56d0e5cba6aa1b70fa0">RegionType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_Region {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The region over which iteration is defined. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00608">608</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<a id="a1bb8837056d746fa9bce4078edd5ff09" name="a1bb8837056d746fa9bce4078edd5ff09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb8837056d746fa9bce4078edd5ff09">&#9670;&nbsp;</a></span>m_WrapOffset</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TImage , typename TBoundaryCondition  = ZeroFluxNeumannBoundaryCondition&lt;TImage&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classitk_1_1ConstNeighborhoodIterator.html#ae1f52d953024abd4f13df12ba2469a53">OffsetType</a> <a class="el" href="classitk_1_1ConstNeighborhoodIterator.html">itk::ConstNeighborhoodIterator</a>&lt; TImage, TBoundaryCondition &gt;::m_WrapOffset { { 0 } }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The internal array of offsets that provide support for regions of interest. An offset for each dimension is necessary to shift pointers when wrapping around region edges because region memory is not necessarily contiguous within the buffer. </p>

<p class="definition">Definition at line <a class="el" href="itkConstNeighborhoodIterator_8h_source.html#l00615">615</a> of file <a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="itkConstNeighborhoodIterator_8h_source.html">itkConstNeighborhoodIterator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<hr class="footer"/>
<div class="footer" align="left">
  <small>Tarballs of the nightly generated Doxygen documentation are available
    for the
    <a href="https://itk.org/files/NightlyDoxygen/InsightDoxygenDocHtml.tar.gz">html</a>,
    <a href="https://itk.org/files/NightlyDoxygen/InsightDoxygenDocXml.tar.gz">xml</a>, and
    <a href="https://itk.org/files/NightlyDoxygen/InsightDoxygenDocTag.gz">tag file</a>.
  Previous versions of this documentation for version:
    <a href="https://itk.org/Doxygen53/html/index.html">5.3</a>,
    <a href="https://itk.org/Doxygen52/html/index.html">5.2</a>,
    <a href="https://itk.org/Doxygen51/html/index.html">5.1</a>,
    <a href="https://itk.org/Doxygen50/html/index.html">5.0</a>,
    <a href="https://itk.org/Doxygen413/html/index.html">4.13</a>,
    <a href="https://itk.org/Doxygen320/html/index.html">3.20</a>.
  </small>
</div>
<address class="footer"><small>
Generated on <span id="datetime">unknown</span> for ITK by &#160;
<a href="https://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.3
</small></address>
</body>
</html>
